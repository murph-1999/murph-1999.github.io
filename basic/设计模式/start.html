<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Murphy</title>
    <meta name="description" content="为学应尽毕生力，攀高须贵少年时">
    <meta name="generator" content="VitePress v1.3.4">
    <link rel="preload stylesheet" href="/assets/style.DW2__20A.css" as="style">
    
    <script type="module" src="/assets/app.D9BLfna4.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.Q0X2mdF-.js">
    <link rel="modulepreload" href="/assets/chunks/theme.BWczLCoW.js">
    <link rel="modulepreload" href="/assets/chunks/katex.TTlFrSdt.js">
    <link rel="modulepreload" href="/assets/chunks/c4Diagram-b2a90758.LUYqfxrL.js">
    <link rel="modulepreload" href="/assets/chunks/flowDiagram-5540d9b9.DwkIkp6R.js">
    <link rel="modulepreload" href="/assets/chunks/flowDiagram-v2-3b53844e.BPIgsuvu.js">
    <link rel="modulepreload" href="/assets/chunks/erDiagram-47591fe2.-n4gEIPG.js">
    <link rel="modulepreload" href="/assets/chunks/gitGraphDiagram-96e6b4ee.m2ypKbC2.js">
    <link rel="modulepreload" href="/assets/chunks/ganttDiagram-9a3bba1f.CSmkjA6K.js">
    <link rel="modulepreload" href="/assets/chunks/infoDiagram-bcd20f53.FfstzbyE.js">
    <link rel="modulepreload" href="/assets/chunks/pieDiagram-79897490.DR4tViyj.js">
    <link rel="modulepreload" href="/assets/chunks/quadrantDiagram-62f64e94.Bib8v-zn.js">
    <link rel="modulepreload" href="/assets/chunks/xychartDiagram-ab372869.BxBJWDyB.js">
    <link rel="modulepreload" href="/assets/chunks/requirementDiagram-05bf5f74.DD7ZyHZI.js">
    <link rel="modulepreload" href="/assets/chunks/sequenceDiagram-acc0e65c.D1XH4Md3.js">
    <link rel="modulepreload" href="/assets/chunks/classDiagram-30eddba6.Bs7QbuEU.js">
    <link rel="modulepreload" href="/assets/chunks/classDiagram-v2-f2df5561.CrCGfTRr.js">
    <link rel="modulepreload" href="/assets/chunks/stateDiagram-0ff1cf1a.BV9ipKyx.js">
    <link rel="modulepreload" href="/assets/chunks/stateDiagram-v2-9a9d610d.D8gmPD-E.js">
    <link rel="modulepreload" href="/assets/chunks/journeyDiagram-4fe6b3dc.CVm7Tr0v.js">
    <link rel="modulepreload" href="/assets/chunks/flowchart-elk-definition-5fe447d6.Dbv9cviZ.js">
    <link rel="modulepreload" href="/assets/chunks/timeline-definition-fea2a41d.4VNFHNki.js">
    <link rel="modulepreload" href="/assets/chunks/mindmap-definition-f354de21.D2_58KKY.js">
    <link rel="modulepreload" href="/assets/chunks/sankeyDiagram-97764748.Fgil-UBv.js">
    <link rel="modulepreload" href="/assets/chunks/blockDiagram-91b80b7a.DXKmGyC7.js">
    <link rel="modulepreload" href="/assets/chunks/virtual_mermaid-config.DDnGl6nM.js">
    <link rel="modulepreload" href="/assets/basic_设计模式_start.md.BERhNYiz.lean.js">
    <link rel="icon" href="img/icon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
    <script type="text/javascript">(function(){document.documentElement.setAttribute("theme","el-blue")})();</script>
    <script>import("/pagefind/pagefind.js").then(i=>{window.__pagefind__=i,i.init()}).catch(()=>{});</script>
  </head>
  <body>
    <div id="app"><div class="Layout blog-theme-layout" data-v-5e326c4e data-v-5d98c3a5><!--[--><!--[--><!--]--><!----><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar top" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle" data-v-6aa21345 data-v-ab179fa1><a class="title" href="/" data-v-ab179fa1><!--[--><!--]--><!--[--><img class="VPImage logo" src="/img/icon.png" alt data-v-8426fc1a><!--]--><span data-v-ab179fa1>Murphy</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="blog-search search" data-pagefind-ignore="all" data-v-6aa21345 data-v-a656b39e><div class="nav-search-btn-wait" data-v-a656b39e><span data-v-a656b39e><svg width="14" height="14" viewBox="0 0 20 20" data-v-a656b39e><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" data-v-a656b39e></path></svg></span><span class="search-tip" data-v-a656b39e>Search</span><span class="metaKey" data-v-a656b39e> K </span></div><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-dc692963 data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>基础知识汇总</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-b98bc113><div class="items" data-v-b98bc113><!--[--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-43f1e123><a class="VPLink link" href="/basic/js/this.html" data-v-43f1e123><!--[-->js<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-43f1e123><a class="VPLink link" href="/basic/css/start.html" data-v-43f1e123><!--[-->css<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-43f1e123><a class="VPLink link" href="/basic/html/start.html" data-v-43f1e123><!--[-->html<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-43f1e123><a class="VPLink link" href="/basic/es6/start.html" data-v-43f1e123><!--[-->es6<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-43f1e123><a class="VPLink link" href="/basic/ts/start.html" data-v-43f1e123><!--[-->ts<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-43f1e123><a class="VPLink link" href="/basic/npm/install.html" data-v-43f1e123><!--[-->npm<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-43f1e123><a class="VPLink link" href="/basic/deploy/nginx.html" data-v-43f1e123><!--[-->部署<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-dc692963 data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>vue</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-b98bc113><div class="items" data-v-b98bc113><!--[--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-43f1e123><a class="VPLink link" href="/vue/" data-v-43f1e123><!--[-->vue2源码<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-43f1e123><a class="VPLink link" href="/vue/" data-v-43f1e123><!--[-->vue3源码<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/build/webpack.html" tabindex="0" data-v-dc692963 data-v-9c663999><!--[--><span data-v-9c663999>自动化构建</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/explore/nexus.html" tabindex="0" data-v-dc692963 data-v-9c663999><!--[--><span data-v-9c663999>Explore</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/murph-1999" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b6c34ac9><span class="vpi-more-horizontal icon" data-v-b6c34ac9></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/murph-1999" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>回到顶部</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>目录</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--[--><!--[--><!--[--><!--]--><!----><!--]--><!--]--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _basic_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_start" data-v-39a288b8><div data-pagefind-body="true"><h2 id="几个问题" tabindex="-1">几个问题 <a class="header-anchor" href="#几个问题" aria-label="Permalink to &quot;几个问题&quot;">​</a></h2><h3 id="动态类型语言与静态类型语言的区别" tabindex="-1">动态类型语言与静态类型语言的区别 <a class="header-anchor" href="#动态类型语言与静态类型语言的区别" aria-label="Permalink to &quot;动态类型语言与静态类型语言的区别&quot;">​</a></h3><h3 id="面向接口编程和面向实现编程的区别" tabindex="-1">面向接口编程和面向实现编程的区别 <a class="header-anchor" href="#面向接口编程和面向实现编程的区别" aria-label="Permalink to &quot;面向接口编程和面向实现编程的区别&quot;">​</a></h3><h3 id="多态含义-js需要多态吗" tabindex="-1">多态含义 js需要多态吗？ <a class="header-anchor" href="#多态含义-js需要多态吗" aria-label="Permalink to &quot;多态含义 js需要多态吗？&quot;">​</a></h3><blockquote><h3 id="而-javascript-的变量类型在运行期是可变的。一个-javascript-对象-既可以表示-duck-类型的" tabindex="-1">而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以表示 Duck 类型的 <a class="header-anchor" href="#而-javascript-的变量类型在运行期是可变的。一个-javascript-对象-既可以表示-duck-类型的" aria-label="Permalink to &quot;而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以表示 Duck 类型的&quot;">​</a></h3><p>对象，又可以表示 Chicken 类型的对象，这意味着 JavaScript 对象的多态性是与生俱来的。</p><p>这种与生俱来的多态性并不难解释。JavaScript 作为一门动态类型语言，它在编译时没有类型</p><p>检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。在 1.2.2 节的代码示例中，</p><p>我们既可以往 makeSound 函数里传递 duck 对象当作参数，也可以传递 chicken 对象当作参数。</p><p>由此可见，某一种动物能否发出叫声，只取决于它有没有 makeSound 方法，而不取决于它是</p><p>否是某种类型的对象，这里不存在任何程度上的“类型耦合”。这正是我们从上一节的鸭子类型</p><p>中领悟的道理。在 JavaScript 中，并不需要诸如向上转型之类的技术来取得多态的效果。</p></blockquote><h3 id="更广义的封装" tabindex="-1">更广义的封装 <a class="header-anchor" href="#更广义的封装" aria-label="Permalink to &quot;更广义的封装&quot;">​</a></h3><p>封装不仅仅是 隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。</p><h3 id="aop面向切面编程" tabindex="-1">AOP面向切面编程 <a class="header-anchor" href="#aop面向切面编程" aria-label="Permalink to &quot;AOP面向切面编程&quot;">​</a></h3><p>将与核心业务逻辑模块无关的功能抽离出来</p><p>在js中实现aop，指的是把一个函数动态植入到另一个函数中</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Function.prototype.before = function( beforefn ){</span></span>
<span class="line"><span> var __self = this; // 保存原函数的引用</span></span>
<span class="line"><span> return function(){ // 返回包含了原函数和新函数的&quot;代理&quot;函数</span></span>
<span class="line"><span> 	beforefn.apply( this, arguments ); // 执行新函数，修正 this</span></span>
<span class="line"><span> 	return __self.apply( this, arguments ); // 执行原函数</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Function.prototype.after = function( afterfn ){</span></span>
<span class="line"><span> var __self = this;</span></span>
<span class="line"><span> return function(){</span></span>
<span class="line"><span> 	var ret = __self.apply( this, arguments );</span></span>
<span class="line"><span> 	afterfn.apply( this, arguments );</span></span>
<span class="line"><span> 	return ret;</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var func = function(){</span></span>
<span class="line"><span> console.log( 2 );</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func = func.before(function(){</span></span>
<span class="line"><span> console.log( 1 );</span></span>
<span class="line"><span>}).after(function(){</span></span>
<span class="line"><span> console.log( 3 );</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func();</span></span></code></pre></div><p>使用aop的方式来给函数添加职责，是js中一种巧妙的装饰者模式实现。</p><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><p>学习设计模式前需要知道的几个点：</p><ol><li>将不变的部分与变化的部分隔开是每个设计模式的主题</li></ol><h3 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h3><h4 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>保证一个类只有一个实例，并提供一个访问它的全局访问点</p><h4 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h4><p>多次点击登录按钮，浮窗弹出，而不管登录按钮点击了多少次，浮窗应该只创建一次</p><p>这个在vue开发中也有所体现，比如一个悬浮提示</p><h4 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h4><p>实现的原则就是用一个变量来标志当前是否已经为某个类创建过对象。如果是，下一次访问该类的实例时，直接返回之前创建的对象。</p><p>比较好的实现方式：</p><p>代理方式</p><h4 id="js中的单例模式" tabindex="-1">js中的单例模式 <a class="header-anchor" href="#js中的单例模式" aria-label="Permalink to &quot;js中的单例模式&quot;">​</a></h4><p>js是无类语言，使用字面量方式创建一个对象，它就是唯一的，而且可以被全局访问。但是就全局变量而言，很容易造成命名空间污染。比如变量被覆盖等等</p><p>有两种方式可以避免：</p><ol><li>使用命名空间</li></ol><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var namespace1 = {</span></span>
<span class="line"><span> a: function(){</span></span>
<span class="line"><span> alert (1);</span></span>
<span class="line"><span> },</span></span>
<span class="line"><span> b: function(){</span></span>
<span class="line"><span> alert (2);</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>};</span></span></code></pre></div><ol start="2"><li>使用闭包封装私有变量</li></ol><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var user = (function(){</span></span>
<span class="line"><span> var __name = &#39;sven&#39;,</span></span>
<span class="line"><span> __age = 29;</span></span>
<span class="line"><span> return {</span></span>
<span class="line"><span> getUserInfo: function(){</span></span>
<span class="line"><span> return __name + &#39;-&#39; + __age;</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>})();</span></span></code></pre></div><h4 id="惰性单例" tabindex="-1">惰性单例 <a class="header-anchor" href="#惰性单例" aria-label="Permalink to &quot;惰性单例&quot;">​</a></h4><p>在需要使用到的时候才创建对象</p><h3 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h3><h4 id="定义-1" tabindex="-1">定义 <a class="header-anchor" href="#定义-1" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>使用一系列的算法，把它们一个个封装起来，并且相互可以替换</p><h4 id="实现-1" tabindex="-1">实现 <a class="header-anchor" href="#实现-1" aria-label="Permalink to &quot;实现&quot;">​</a></h4><p>一个基于策略模式的程序至少有两部分组成：</p><ol><li>一组策略类，封装具体的算法，并负责具体的计算过程</li><li>环境类context，接收客户的请求，之后将请求委托给某一个策略类</li></ol><p>因此context中要维护对某个策略对象的引用</p><h4 id="js中的实现" tabindex="-1">js中的实现 <a class="header-anchor" href="#js中的实现" aria-label="Permalink to &quot;js中的实现&quot;">​</a></h4><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var strategies = {</span></span>
<span class="line"><span> &quot;S&quot;: function( salary ){</span></span>
<span class="line"><span> return salary * 4;</span></span>
<span class="line"><span> },</span></span>
<span class="line"><span> &quot;A&quot;: function( salary ){</span></span>
<span class="line"><span> return salary * 3;</span></span>
<span class="line"><span> },</span></span>
<span class="line"><span> &quot;B&quot;: function( salary ){</span></span>
<span class="line"><span> return salary * 2;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var calculateBonus = function( level, salary ){</span></span>
<span class="line"><span> return strategies[ level ]( salary );</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>console.log( calculateBonus( &#39;S&#39;, 20000 ) ); // 输出：80000</span></span>
<span class="line"><span>console.log( calculateBonus( &#39;A&#39;, 10000 ) ); // 输出：30000</span></span></code></pre></div><p>这里体现了对象多态性， 。替换 Context 中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。</p><p>结合高阶函数的实现</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var S = function( salary ){</span></span>
<span class="line"><span> return salary * 4;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>var A = function( salary ){</span></span>
<span class="line"><span> return salary * 3;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>var B = function( salary ){</span></span>
<span class="line"><span> return salary * 2;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>var calculateBonus = function( func, salary ){</span></span>
<span class="line"><span> return func( salary );</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>calculateBonus( S, 10000 ); // 输出：40000</span></span></code></pre></div><blockquote><p>在函数作为一等对象的语言中，策略模式是隐形的，strategy就是值为函数的变量</p></blockquote><p>实际上在 JavaScript 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身</p><p>当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函</p><p>数发出“调用”的消息时，不同的函数会返回不同的执行结果。</p><p>因此可以说在js中，函数对象的多态性来的更加简单。</p><h4 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h4><p>优点：</p><p> 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</p><p> 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它</p><p>们易于切换，易于理解，易于扩展。</p><p> 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。</p><p> 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻</p><p>便的替代方案。</p><p>缺点：</p><p>对于每一个策略<code>strategy</code>都必须了解清楚，违背了最少知识原则。</p><h3 id="代理模式" tabindex="-1">代理模式 <a class="header-anchor" href="#代理模式" aria-label="Permalink to &quot;代理模式&quot;">​</a></h3><h4 id="定义-2" tabindex="-1">定义 <a class="header-anchor" href="#定义-2" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>为一个对象提供一个代用品或者占位符，以便控制对他的访问</p><h4 id="关键" tabindex="-1">关键 <a class="header-anchor" href="#关键" aria-label="Permalink to &quot;关键&quot;">​</a></h4><p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身</p><p>对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之</p><p>后，再把请求转交给本体对象</p><h4 id="保护代理与虚拟代理" tabindex="-1">保护代理与虚拟代理 <a class="header-anchor" href="#保护代理与虚拟代理" aria-label="Permalink to &quot;保护代理与虚拟代理&quot;">​</a></h4><ol><li>虚拟代理</li></ol><p>等到合适的情况下，代理再执行操作。</p><p>虚拟代理把一些开销很大的对象，延迟到 真正需要它的时候才去创建</p><ol start="2"><li>保护代理</li></ol><p>用于控制不同权限的对象对目标对象的访问，但在 JavaScript 并不容易实现保护代 理，因为我们无法判断谁访问了某个对象</p><h4 id="代理的意义" tabindex="-1">代理的意义 <a class="header-anchor" href="#代理的意义" aria-label="Permalink to &quot;代理的意义&quot;">​</a></h4><p>符合单一职责原则和开放封闭原则</p><h4 id="案例" tabindex="-1">案例 <a class="header-anchor" href="#案例" aria-label="Permalink to &quot;案例&quot;">​</a></h4><ol><li>虚拟代理合并请求</li><li>虚拟代理在惰性加载中的应用</li></ol><h4 id="缓存代理" tabindex="-1">缓存代理 <a class="header-anchor" href="#缓存代理" aria-label="Permalink to &quot;缓存代理&quot;">​</a></h4><p>缓存代理在平时的编程中应用的非常多，尤其是结合了高阶函数之后</p><p>比如重复的计算结果，重复的异步请求（前提是每次请求的结果是一致的）</p><h3 id="迭代器模式" tabindex="-1">迭代器模式 <a class="header-anchor" href="#迭代器模式" aria-label="Permalink to &quot;迭代器模式&quot;">​</a></h3><!----><!----><h4 id="定义-3" tabindex="-1">定义 <a class="header-anchor" href="#定义-3" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象</p><p>的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即</p><p>使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p><h4 id="内部迭代器和外部迭代器" tabindex="-1">内部迭代器和外部迭代器 <a class="header-anchor" href="#内部迭代器和外部迭代器" aria-label="Permalink to &quot;内部迭代器和外部迭代器&quot;">​</a></h4><p>内部迭代器调用的时候非常方便，外界不用关心迭代器内部的实现，但是此时迭代规则也确定了，不能够更改。相对来说，外部迭代器必须显式地请求迭代下一个元素。他们俩的使用需要看具体场景。</p><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><h4 id="实例" tabindex="-1">实例 <a class="header-anchor" href="#实例" aria-label="Permalink to &quot;实例&quot;">​</a></h4><p>可以改造if else语句相关逻辑</p><p>以next-tick.js源码为例！promise-》mutation-》setImmediate</p><h3 id="发布订阅模式" tabindex="-1">发布订阅模式 <a class="header-anchor" href="#发布订阅模式" aria-label="Permalink to &quot;发布订阅模式&quot;">​</a></h3><h4 id="定义-4" tabindex="-1">定义 <a class="header-anchor" href="#定义-4" aria-label="Permalink to &quot;定义&quot;">​</a></h4><!----><!----><!----><!----><!----><p><strong><!----></strong></p><p><em><strong><!----></strong></em></p><!----><!---->**<!---->**<!----><!----><!----><h4 id="必须先订阅再发布吗" tabindex="-1">必须先订阅再发布吗 <a class="header-anchor" href="#必须先订阅再发布吗" aria-label="Permalink to &quot;必须先订阅再发布吗&quot;">​</a></h4><p>不一定，因为受一些不确定的因素影响，比如异步消息返回的比较快，也就是已经发布了信息，但是订阅者还未来得及订阅，特别使用了一些模块化惰性加载的时候，</p><!----><!----><!----><!----><!----><!----><h4 id="js实现发布订阅模式的便利性" tabindex="-1"><!----> <a class="header-anchor" href="#js实现发布订阅模式的便利性" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;js实现发布订阅模式的便利性&lt;/font&gt;&quot;">​</a></h4><ol><li><!----></li><li><!----></li></ol><!----><h4 id="发布订阅模式的缺点" tabindex="-1"><!----> <a class="header-anchor" href="#发布订阅模式的缺点" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;发布订阅模式的缺点&lt;/font&gt;&quot;">​</a></h4><blockquote><h4 id="创建订阅者本身要消耗一定的时间和内存-而" tabindex="-1"><!----> <a class="header-anchor" href="#创建订阅者本身要消耗一定的时间和内存-而" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;创建订阅者本身要消耗一定的时间和内存，而 &lt;/font&gt;&quot;">​</a></h4><!----><!----><!----><!----><!----><!----></blockquote><h3 id="命令模式" tabindex="-1">命令模式 <a class="header-anchor" href="#命令模式" aria-label="Permalink to &quot;命令模式&quot;">​</a></h3><h4 id="定义-5" tabindex="-1">定义 <a class="header-anchor" href="#定义-5" aria-label="Permalink to &quot;定义&quot;">​</a></h4><!----><p><em><strong><!----></strong></em></p><p><em><strong><!----></strong></em></p><h4 id="js中的命令模式" tabindex="-1">js中的命令模式 <a class="header-anchor" href="#js中的命令模式" aria-label="Permalink to &quot;js中的命令模式&quot;">​</a></h4><p>命令模式的由来，其实是回调函数的一个面向对象的替代品</p><p>js作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到js中，因为函数作为一等公民（对象），本身就可以被四处传递，可作为参数传入，可返回。</p><p>因此可以使用闭包的方式来实现</p><h4 id="可定义的行为" tabindex="-1">可定义的行为 <a class="header-anchor" href="#可定义的行为" aria-label="Permalink to &quot;可定义的行为&quot;">​</a></h4><p>命令模式的作用不仅是封装运算块，<!----></p><p>执行（execute）/撤销（）</p><p>还可用于ctrl+Z和悔棋的功能，</p><h4 id="撤销和重做" tabindex="-1">撤销和重做 <a class="header-anchor" href="#撤销和重做" aria-label="Permalink to &quot;撤销和重做&quot;">​</a></h4><p>对于不容易直接逆转的操作，像让小球移动到上一个位置这样的行为（撤销），可以记录下当前已经执行过的所有命令，然后重播，从头再执行一遍这些命令。</p><h4 id="实践" tabindex="-1">实践 <a class="header-anchor" href="#实践" aria-label="Permalink to &quot;实践&quot;">​</a></h4><p>实现一个案例，结合策略模式，发布订阅模式，命令模式</p><ol><li>策略模式：一个小球以不同的方式进行移动； 5.4</li><li>命令模式：手动给一个指令，前进或撤销或重置来操作小球，如果点击的过快，也应该执行完上一次再继续执行下一次，而不是直接重新执行，也就是实现一个命令队列；先通过回调来完成下一次出队执行9.6</li><li>发布订阅模式：上一次动画结束之后，notify，通知队列，队列的 update 就是出队第一个元素，且这个元素执行完成后，依旧是通知订阅者。8.4</li></ol><!----><!----><!----><!----><!----><!----><!----><!----><h4 id="宏命令" tabindex="-1">宏命令 <a class="header-anchor" href="#宏命令" aria-label="Permalink to &quot;宏命令&quot;">​</a></h4><!----><!----><h4 id="智能模式与傻瓜命令" tabindex="-1"><!----> <a class="header-anchor" href="#智能模式与傻瓜命令" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;智能模式与傻瓜命令&lt;/font&gt;&quot;">​</a></h4><!----><!----><!----><!----><!---->**<!---->**<p><strong><!---->****<!----></strong></p><p><strong><!----></strong></p><p><strong><!----></strong></p><p><strong><!----></strong></p><p><strong><!----></strong></p><h3 id="组合模式" tabindex="-1">组合模式 <a class="header-anchor" href="#组合模式" aria-label="Permalink to &quot;组合模式&quot;">​</a></h3><h4 id="定义-6" tabindex="-1">定义 <a class="header-anchor" href="#定义-6" aria-label="Permalink to &quot;定义&quot;">​</a></h4><!----><!----><!----><p><strong>用途</strong></p><p>利用对象多态性统一对待组合对象和单个对象，可以忽略组合对象个单个对象的不同，只要都能执行命令就行</p><h4 id="更强大的宏命令" tabindex="-1">更强大的宏命令 <a class="header-anchor" href="#更强大的宏命令" aria-label="Permalink to &quot;更强大的宏命令&quot;">​</a></h4><p>基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，再进行深度优先便可以遍历整棵树，书上的例子又体现了我们可以忽视对象和多个对象的区别，只要保证它们都有<code>execute</code>方法。</p><p>这有点像函数式编程中函数组合<code>compose</code>的概念</p><h4 id="js中的组合模式" tabindex="-1">js中的组合模式 <a class="header-anchor" href="#js中的组合模式" aria-label="Permalink to &quot;js中的组合模式&quot;">​</a></h4><!----><!----><!----><!----><h4 id="需要注意的地方" tabindex="-1"><!----> <a class="header-anchor" href="#需要注意的地方" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;需要注意的地方&lt;/font&gt;&quot;">​</a></h4><ol><li><!----></li><li><!----></li></ol><ul><li>组合对象与叶对象具有相同的接口</li><li>对一组叶对象的操作必须具有一致性</li></ul><ol start="3"><li><!----></li><li><!----></li></ol><!----><h4 id="在组合模式中使用职责链" tabindex="-1"><!----> <a class="header-anchor" href="#在组合模式中使用职责链" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;在组合模式中使用职责链&lt;/font&gt;&quot;">​</a></h4><ul><li>[ ] 一个删除文件夹的例子，结合职责链来实现！</li></ul><h4 id="组合模式的优缺点" tabindex="-1">组合模式的优缺点 <a class="header-anchor" href="#组合模式的优缺点" aria-label="Permalink to &quot;组合模式的优缺点&quot;">​</a></h4><ol><li>优点</li></ol><ul><li><!----></li></ul><!----><!----><!----><!----><!----><ul><li><!----></li></ul><!----><!----><!----><!----><!----><!----><!----><!----><ol start="2"><li><!----></li></ol><!----><!----><h3 id="模板方法模式" tabindex="-1"><!----> <a class="header-anchor" href="#模板方法模式" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;模板方法模式&lt;/font&gt;&quot;">​</a></h3><h4 id="定义-7" tabindex="-1"><!----> <a class="header-anchor" href="#定义-7" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;定义&lt;/font&gt;&quot;">​</a></h4><!----> <!----><!----><h4 id="组成" tabindex="-1"><!----> <a class="header-anchor" href="#组成" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;组成&lt;/font&gt;&quot;">​</a></h4><!----><!---->**<!---->**<!----><!----><h4 id="抽象类" tabindex="-1"><!----> <a class="header-anchor" href="#抽象类" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;抽象类&lt;/font&gt;&quot;">​</a></h4><p>模板方法模式严重依赖抽象类，js在语言层面上并没有提供对抽象类的支持。</p><!----><!----><!----><h4 id="使用场景" tabindex="-1"><!----> <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;使用场景&lt;/font&gt;&quot;">​</a></h4><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><h4 id="钩子方法" tabindex="-1"><!----> <a class="header-anchor" href="#钩子方法" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;钩子方法&lt;/font&gt;&quot;">​</a></h4><!----><!----><!----><h4 id="好莱坞原则" tabindex="-1"><!----> <a class="header-anchor" href="#好莱坞原则" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;好莱坞原则&lt;/font&gt;&quot;">​</a></h4><!----><ol><li><!----></li><li><!----></li><li><!----></li></ol><p>这三个都符合好莱坞原则</p><h4 id="js中真的需要继承吗" tabindex="-1">js中真的需要继承吗 <a class="header-anchor" href="#js中真的需要继承吗" aria-label="Permalink to &quot;js中真的需要继承吗&quot;">​</a></h4><!----><!----><h3 id="亨元模式" tabindex="-1">亨元模式 <a class="header-anchor" href="#亨元模式" aria-label="Permalink to &quot;亨元模式&quot;">​</a></h3><h4 id="定义-8" tabindex="-1">定义 <a class="header-anchor" href="#定义-8" aria-label="Permalink to &quot;定义&quot;">​</a></h4><!----><!----><!----><!----><!----><p><em><strong><!----></strong>__** **</em></p><p><em><strong><!----></strong></em></p><!----><p><strong><!----></strong></p><h4 id="内部状态和外部状态" tabindex="-1"><!----> <a class="header-anchor" href="#内部状态和外部状态" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;内部状态和外部状态&lt;/font&gt;&quot;">​</a></h4><!----><ul><li><!----></li><li><!----></li><li><!----></li><li><!----></li></ul><!----><h4 id="通用结构" tabindex="-1">通用结构 <a class="header-anchor" href="#通用结构" aria-label="Permalink to &quot;通用结构&quot;">​</a></h4><ol><li>只有当某种共享对象被真正需要时，它才从工厂中被创建出来</li><li>当外部状态非常复杂时，他们与共享对象的联系会变得十分困难，因此将使用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子与共享对象联系起来。</li></ol><h4 id="使用场景-1" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景-1" aria-label="Permalink to &quot;使用场景&quot;">​</a></h4><ol><li><!----></li><li><!----></li><li><!---->**<!---->**</li><li><!----></li></ol><!----><!----><h4 id="没有内部状态的亨元和没有外部状态的亨元" tabindex="-1"><!----> <a class="header-anchor" href="#没有内部状态的亨元和没有外部状态的亨元" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;没有内部状态的亨元和没有外部状态的亨元&lt;/font&gt;&quot;">​</a></h4><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var Upload = function(){};</span></span>
<span class="line"><span>var UploadFactory = (function(){</span></span>
<span class="line"><span>var uploadObj;</span></span>
<span class="line"><span> return {</span></span>
<span class="line"><span> create: function(){</span></span>
<span class="line"><span> if ( uploadObj ){</span></span>
<span class="line"><span> return uploadObj;</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> return uploadObj = new Upload();</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>})();</span></span></code></pre></div><!----><!----><h4 id="对象池技术" tabindex="-1"><!----> <a class="header-anchor" href="#对象池技术" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;对象池技术&lt;/font&gt;&quot;">​</a></h4><!----><!----><!----><!----><!----><!----><h3 id="职责链模式" tabindex="-1"><!----> <a class="header-anchor" href="#职责链模式" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;职责链模式&lt;/font&gt;&quot;">​</a></h3><h4 id="定义-9" tabindex="-1"><!----> <a class="header-anchor" href="#定义-9" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;定义&lt;/font&gt;&quot;">​</a></h4><!----><!----><!----><h4 id="灵活可拆分的职责链节点" tabindex="-1"><!----> <a class="header-anchor" href="#灵活可拆分的职责链节点" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;灵活可拆分的职责链节点&lt;/font&gt;&quot;">​</a></h4><!----><!----><h4 id="异步的职责链" tabindex="-1"><!----> <a class="header-anchor" href="#异步的职责链" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;异步的职责链&lt;/font&gt;&quot;">​</a></h4><!----><!----><h4 id="职责链模式的优缺点" tabindex="-1">职责链模式的优缺点 <a class="header-anchor" href="#职责链模式的优缺点" aria-label="Permalink to &quot;职责链模式的优缺点&quot;">​</a></h4><p>优点：</p><ol><li>解耦了请求发送者和n个接受者之间的复杂关系</li><li><!----></li></ol><!----><ol start="3"><li><!----></li></ol><!----><!----><ol><li><!----></li><li><!----></li></ol><!----><h4 id="用aop实现职责链" tabindex="-1"><!----> <a class="header-anchor" href="#用aop实现职责链" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;用Aop实现职责链&lt;/font&gt;&quot;">​</a></h4><p>结合AOP，叠加了函数的作用域，虽然把函数叠加在一起，但如果链条太长的话，可能会对性能造成影响。</p><h4 id="应用-1" tabindex="-1">应用 <a class="header-anchor" href="#应用-1" aria-label="Permalink to &quot;应用&quot;">​</a></h4><!----><!----><!----><!----><h3 id="中介者模式" tabindex="-1"><!----> <a class="header-anchor" href="#中介者模式" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;中介者模式&lt;/font&gt;&quot;">​</a></h3><h4 id="定义-10" tabindex="-1">定义 <a class="header-anchor" href="#定义-10" aria-label="Permalink to &quot;定义&quot;">​</a></h4><!----><!----><h4 id="案例-1" tabindex="-1"><!----> <a class="header-anchor" href="#案例-1" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;案例&lt;/font&gt;&quot;">​</a></h4><!----><!----><h4 id="最少知识原则" tabindex="-1"><!----> <a class="header-anchor" href="#最少知识原则" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;最少知识原则&lt;/font&gt;&quot;">​</a></h4><!----><!----><h4 id="缺点" tabindex="-1"><!----> <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;缺点&lt;/font&gt;&quot;">​</a></h4><!----><!----><h3 id="装饰者模式" tabindex="-1"><!----> <a class="header-anchor" href="#装饰者模式" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;装饰者模式&lt;/font&gt;&quot;">​</a></h3><h4 id="定义-11" tabindex="-1">定义 <a class="header-anchor" href="#定义-11" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象</p><p>并且不改变对象自身，只是在程序运行期间给对象动态地添加职责。</p><h4 id="装饰函数" tabindex="-1">装饰函数 <a class="header-anchor" href="#装饰函数" aria-label="Permalink to &quot;装饰函数&quot;">​</a></h4><p>在不改变函数源代码的情况下，给函数增加功能。普通的用一个变量来保存函数就可以实现，但是要注意this绑定丢失的问题。</p><h4 id="aop结合装饰者模式" tabindex="-1">AOP结合装饰者模式 <a class="header-anchor" href="#aop结合装饰者模式" aria-label="Permalink to &quot;AOP结合装饰者模式&quot;">​</a></h4><ol><li>降低耦合性，两个层面的功能使用AOP进行分离</li><li>aop动态改变函数参数，<strong>一个例子就是在axios请求前给请求头加上token参数</strong></li><li><strong>插件式的表单验证，使用before分离了表单验证和表单提交</strong></li></ol><hr><p><strong>tip：</strong></p><p><strong>这么做的缺点：这种装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会有一些影响。</strong></p><p>装饰者模式和代理模式</p><p>通过例子思考两者的区别</p><h3 id="状态模式" tabindex="-1">状态模式 <a class="header-anchor" href="#状态模式" aria-label="Permalink to &quot;状态模式&quot;">​</a></h3><h4 id="定义-12" tabindex="-1">定义 <a class="header-anchor" href="#定义-12" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>维护内部状态，将内部状态与对应的行为局部化</p><h4 id="应用-2" tabindex="-1">应用 <a class="header-anchor" href="#应用-2" aria-label="Permalink to &quot;应用&quot;">​</a></h4><p>状态模式对于实际中的应用非常重要，以一个电灯的案例我联想到项目中的排序按钮，先平序，然后增序，最后降序。原来的写法明显违背了开放封闭原则，换做是其他的案例，则根本不知道有多少个状态，当初我的解决办法是加了一个取模，使用状态模式是否更好地解决这个问题呢?是可以的，</p><p>先看一下element-plus/table中的处理</p><p><a href="https://github.com/element-plus/element-plus/blob/67037470324a12ec152d219542281d1120941295/packages/components/table/src/table-header/event-helper.ts#L142" target="_blank" rel="noreferrer">https://github.com/element-plus/element-plus/blob/67037470324a12ec152d219542281d1120941295/packages/components/table/src/table-header/event-helper.ts#L142</a></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toggleOrder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">order</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sortOrders</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortOrders[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortOrders.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortOrders[index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortOrders.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sortOrders</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ascending&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;descending&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[]</span></span></code></pre></div><p>这种处理方式比取模更好，少了取模的计算。</p><h4 id="关键点" tabindex="-1">关键点 <a class="header-anchor" href="#关键点" aria-label="Permalink to &quot;关键点&quot;">​</a></h4><p>把事物的每种状态都封装成单独的类，跟这种状态有关的行为都被封装在这个类的内部，同时还可以把状态的切换规则事先分布在状态类中。好处就是每一种状态和它对应的行为的关系局部化，这些行为被分散和封装在各自对应的状态类中。</p><h4 id="通用的结构" tabindex="-1">通用的结构 <a class="header-anchor" href="#通用的结构" aria-label="Permalink to &quot;通用的结构&quot;">​</a></h4><p>有一个context状态机，维护着所有状态对象</p><h4 id="优缺点-1" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点-1" aria-label="Permalink to &quot;优缺点&quot;">​</a></h4><p>优点：1. 定义了状态与行为之间的关系，并封装在一个类里</p><ol start="2"><li>避免了context无限膨胀，状态切换的逻辑分布在状态类中</li></ol><p>缺点：会在系统中定义许多的类</p><h4 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h4><p>例子中是为每个context对象都创建了一组state对象，实际上这些state对象之间是可以共享的，使用亨元模式来改写</p><h4 id="策略模式和状态模式的对比" tabindex="-1">策略模式和状态模式的对比 <a class="header-anchor" href="#策略模式和状态模式的对比" aria-label="Permalink to &quot;策略模式和状态模式的对比&quot;">​</a></h4><!----><!----><!----><!----><!----><!----><!----><!----><h4 id="js中的状态机" tabindex="-1"><!----> <a class="header-anchor" href="#js中的状态机" aria-label="Permalink to &quot;&lt;font style=&quot;color:rgb(0,0,0);&quot;&gt;js中的状态机&lt;/font&gt;&quot;">​</a></h4><p>使用委托技术，并不需要事先让一个对象持有另一个对象，在js中可以使用call方法直接把请求委托给某个字面量对象来执行。</p><p>适配器模式</p><p>定义</p><p>解决两个软件实体之间的接口不兼容的问题，别名是包装器</p><p>关键点总结</p><ol><li>是一种亡羊补牢的做法，因为在设计之初并不知道要适配未来的事物</li><li>来自于第三方的api，我们不应该去直接更改他</li></ol><p>和其他设计模式的区别</p><ol><li>和装饰者模式，代理模式，外观模式的区别</li></ol></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><!----><!----></footer><!--[--><!--[--><!--[--><!--[--><!--]--><!----><!--]--><!--]--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"basic_css_start.md\":\"Ca0JZGgt\",\"basic_css_盒模型.md\":\"Ddyf-hxd\",\"basic_css_适配.md\":\"BxWqcYje\",\"basic_deploy_docker.md\":\"Bxl7LsXE\",\"basic_deploy_nginx.md\":\"D429Gfmw\",\"basic_es6_start.md\":\"Cqbo7iPj\",\"basic_git_start.md\":\"Blpp0V9T\",\"basic_html_html5.md\":\"CDzsTMHb\",\"basic_html_start.md\":\"C5NkTqLo\",\"basic_html_适配.md\":\"CHhAMc3Z\",\"basic_js_eventloop.md\":\"BsoZWo1p\",\"basic_js_promise.md\":\"DmB65Vmk\",\"basic_js_this.md\":\"qN3VHVtW\",\"basic_js_函数式编程.md\":\"CJRPSpHH\",\"basic_js_原型.md\":\"GYMrbIG8\",\"basic_js_闭包.md\":\"zETDDvn8\",\"basic_network_basic.md\":\"CoNN_uYC\",\"basic_npm_install.md\":\"Byt-OZZ9\",\"basic_npm_node.md\":\"BEPqy9sR\",\"basic_ts_start.md\":\"BSDkZoh3\",\"basic_设计模式_start.md\":\"BERhNYiz\",\"basic_面试_cv.md\":\"qv5g1o5q\",\"build_optimize.md\":\"B9ehnKY9\",\"build_webpack.md\":\"BE4Pdh_C\",\"explore_change-skin.md\":\"cFdjIh29\",\"explore_echarts.md\":\"zKdmxclV\",\"explore_knowledge-base.md\":\"GpjNbGm9\",\"explore_micro-frontend.md\":\"C1CnC3-D\",\"explore_nexus.md\":\"DG_i4DLI\",\"explore_performance-optimization.md\":\"CYOHMM67\",\"explore_vue-cli-pages.md\":\"C3mNzYE1\",\"explore_vue-el-cascader.md\":\"24-LOhoS\",\"index.md\":\"DtURBaG6\",\"react_differencewithvue.md\":\"C9YqC1Vt\",\"record_20241008.md\":\"DpxtjXEe\",\"standard_css.md\":\"DJFe3zea\",\"standard_eslint.md\":\"CUWIBcKl\",\"standard_git.md\":\"JP82Xkyb\",\"standard_js.md\":\"BpMwYe-q\",\"standard_vue2.md\":\"3IedR9a2\",\"vue_index.md\":\"BO5etGNH\",\"vue_vue-router_01-start.md\":\"D9cT33SJ\",\"vue_vue-router_02-注册路由.md\":\"CLR09mEs\",\"vue_vue-router_03-vuerouter对象.md\":\"DFQ42A4u\",\"vue_vue-router_04-matcher.md\":\"B4cWc-pm\",\"vue_vue-router_05-transition-to.md\":\"saIWqatb\",\"vue_vue-router_06-problem.md\":\"B2NhHtwn\",\"vue_vue-router_07-mini-router.md\":\"CAC5Qaie\",\"vue_vue2_01-start.md\":\"CUSXV6qD\",\"vue_vue2_02-init.md\":\"TV0r3png\",\"vue_vue2_03-mount.md\":\"wESVqaEz\",\"vue_vue2_04-render.md\":\"B-0GJpMG\",\"vue_vue2_05-update.md\":\"CEAGpxBv\",\"vue_vue2_06-firstrender.md\":\"E8qOmPv0\",\"vue_vue2_07-virtualdom.md\":\"DvNSNyPv\",\"vue_vue2_08-reactive.md\":\"CeCxZ5ey\",\"vue_vue2_09-array-reactive.md\":\"COQwBzLr\",\"vue_vue2_10-watcher.md\":\"IOyQEh3x\",\"vue_vue2_11-nexttick.md\":\"CUEWNqou\",\"vue_vue2_12-component.md\":\"NHhqlRMf\",\"vue_vue2_13-component-create.md\":\"CIbmHFJd\",\"vue_vue2_14-patch.md\":\"d7XBcoQp\",\"vue_vue2_15-merge-option.md\":\"CJfvIY9Q\",\"vue_vue2_16-lifecycle.md\":\"DJym61yZ\",\"vue_vue2_17-component-register.md\":\"C8A97neL\",\"vue_vue2_18-async-component.md\":\"8888XWwr\",\"vue_vue2_19-keep-alive.md\":\"C_mTEHWB\",\"vue_vue2_20-extend-v-model.md\":\"Dd7sQDW6\",\"vue_vue2_index.md\":\"CHf0r0ev\",\"vue_vue3_01-reactive.md\":\"Vf3hK-nL\",\"vue_vue3_02-reactive.md\":\"BNYaYoyg\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-cn\",\"dir\":\"ltr\",\"title\":\"Murphy\",\"description\":\"为学应尽毕生力，攀高须贵少年时\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"blog\":{\"pagesData\":[{\"route\":\"/build/optimize\",\"meta\":{\"title\":\"基于 Webpack 的构建速度优化\",\"date\":\"2025-02-23 14:26:38\",\"tag\":[],\"description\":\"背景\\n最近前后端项目放在一起使用 `maven` 打包，但是前端项目打包`npm run build`严重拖累整个项目打包效率，因此研究一下 `vue-cli` 构建优化。\\n项目技术栈：`vue-cl\",\"cover\":\"/assets/dist.BpoWGb2y.png\"}},{\"route\":\"/build/webpack\",\"meta\":{\"title\":\"Webpack basic\",\"date\":\"2025-02-23 16:25:50\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-10-09 20:03:36\\n * @LastEditT\",\"cover\":\"/assets/webpack-loader.Bas_-xbE.png\"}},{\"route\":\"/explore/change-skin\",\"meta\":{\"title\":\"换肤方案\",\"date\":\"2025-01-20 18:07:03\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2025-01-20 18:06:49\\n * @LastEditT\",\"cover\":\"\"}},{\"route\":\"/explore/echarts\",\"meta\":{\"title\":\"一、**大数据量渲染（万级数据点）**\",\"date\":\"2025-02-23 16:58:06\",\"tag\":[],\"description\":\"我经常使用echarts来绘制的图形类型\\n折线图，柱状图，k线图，饼图，散点图，雷达图...\\n---\\n以下是 ECharts 常见复杂场景的处理方案及实践技巧，结合实际开发经验和性能优化策略：\\n---\",\"cover\":\"\"}},{\"route\":\"/explore/knowledge-base\",\"meta\":{\"title\":\"迁移数字花园\",\"date\":\"2025-04-18 16:44:44\",\"tag\":[],\"description\":\"使用notion free版接近一年了，最近块数量已经达到限制，但是$10/month的价格还是让我望而却步了。由于涉及内容较多且日常重度依赖，包括习惯记录等，因此迁移数字花园成为当前优先级最高的事了\",\"cover\":\"\"}},{\"route\":\"/explore/micro-frontend\",\"meta\":{\"title\":\"微前端方案\",\"date\":\"2025-01-20 18:08:36\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/explore/nexus\",\"meta\":{\"title\":\"前端搭建Nexus私有化仓库—附发布一个简单组件案例\",\"date\":\"2024-11-17 16:45:52\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-09-21 13:47:14\\n * @LastEditT\",\"cover\":\"/assets/nexus-store.CAr8pqgn.png\"}},{\"route\":\"/explore/performance-optimization\",\"meta\":{\"title\":\"性能优化\",\"date\":\"2025-02-24 09:59:10\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2025-02-22 09:51:41\\n * @LastEditT\",\"cover\":\"/assets/performance-index.DdqhCHts.png\"}},{\"route\":\"/explore/vue-cli-pages\",\"meta\":{\"title\":\"Vue Cli 构建多页应用\",\"date\":\"2025-01-20 18:00:56\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-09-24 15:45:41\\n * @LastEditT\",\"cover\":\"/assets/pages.mYq6ASt4.png\"}},{\"route\":\"/explore/vue-el-cascader\",\"meta\":{\"title\":\"自定义级联组件\",\"date\":\"2025-07-03 17:17:55\",\"tag\":[],\"description\":\"背景\\n机构数据+账户数据使用一个简单的级联机构可以实现联动，某天产品给出了一户两地的需求，如下：\\n&lt;img src=\\\"./assets/account.png\\\" style=\\\"display: \",\"cover\":\"\"}},{\"route\":\"/react/differenceWithVue\",\"meta\":{\"title\":\"\",\"date\":\"2024-12-26 18:35:13\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-10-29 20:23:27\\n * @LastEditT\",\"cover\":\"\"}},{\"route\":\"/record/20241008\",\"meta\":{\"title\":\"1008喜迎元旦\",\"date\":\"2024-10-09 20:02:28\",\"tag\":[],\"description\":\"时间飞逝，过完今年国庆，下一次的假期就是元旦了。今天是假期后复工第一天，我的心情就如A股港股冰火两重天，“冰”是源自于惭愧，假期7天过于放空，专注力可能有所消散，制定好的计划也未能按时完成；“火”是源\",\"cover\":\"\"}},{\"route\":\"/standard/css\",\"meta\":{\"title\":\"\",\"date\":\"2024-11-22 14:59:35\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/standard/eslint\",\"meta\":{\"title\":\"\",\"date\":\"2024-11-22 14:59:19\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/standard/git\",\"meta\":{\"title\":\"\",\"date\":\"2024-11-22 14:57:51\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/standard/js\",\"meta\":{\"title\":\"\",\"date\":\"2024-11-22 14:58:45\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/standard/vue2\",\"meta\":{\"title\":\"\",\"date\":\"2024-12-26 17:34:24\",\"tag\":[],\"description\":\"几个问题\\n动态类型语言与静态类型语言的区别\\n面向接口编程和面向实现编程的区别\\n多态含义 js需要多态吗？\\n而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以\",\"cover\":\"\"}},{\"route\":\"/vue/index\",\"meta\":{\"hidden\":true,\"readingTime\":false,\"date\":\"2024-10-10 14:12:56\",\"author\":false,\"recommend\":false,\"title\":\"vue2源码阅读\",\"tag\":[],\"description\":\"vue2源码阅读\\n 准备工作\\n- 准备源码\\n 数据驱动\\n- 初始化\\n- 挂载dom\\n- render\\n- update\\n- 首次渲染\\n- 虚拟dom\\n 虚拟DOM\\n- 虚拟DOM\\n 响应式\\n- 响应式\",\"cover\":\"\"}},{\"route\":\"/basic/css/start\",\"meta\":{\"title\":\"\",\"date\":\"2024-10-29 20:10:38\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/css/盒模型\",\"meta\":{\"title\":\"盒模型\",\"date\":\"2025-02-26 11:04:16\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2025-02-26 10:56:15\\n * @LastEditT\",\"cover\":\"\"}},{\"route\":\"/basic/css/适配\",\"meta\":{\"title\":\"为什么需要移动端适配？\",\"date\":\"2024-12-26 18:14:42\",\"tag\":[],\"description\":\"这些都应该是项目初始阶段应该完成的任务，而不是后面修修改改\\n为什么每次做出的页面都很奇怪呢？\\n看稿子怎么设计\\n一般的设计标准是什么，以及如何根据ui设计稿进行调整\\n调整后发现一些样式与组件的样式冲突后\",\"cover\":\"\"}},{\"route\":\"/basic/deploy/docker\",\"meta\":{\"title\":\"\",\"date\":\"2024-10-29 20:28:33\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/deploy/nginx\",\"meta\":{\"title\":\"nginx有哪些作用\",\"date\":\"2025-02-23 16:31:05\",\"tag\":[],\"description\":\"---\\n Nginx 的核心作用及实践场景总结\\nNginx 是一款高性能的 Web 服务器 和 反向代理服务器，同时支持负载均衡、缓存加速、安全防护等功能，广泛应用于现代 Web 架构中。以下是其核心\",\"cover\":\"\"}},{\"route\":\"/basic/es6/start\",\"meta\":{\"title\":\"\",\"date\":\"2024-12-04 19:24:36\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/git/start\",\"meta\":{\"title\":\"\",\"date\":\"2025-05-21 15:53:56\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-12-09 10:35:06\\n * @LastEditT\",\"cover\":\"\"}},{\"route\":\"/basic/html/html5\",\"meta\":{\"title\":\"\",\"date\":\"2024-10-29 20:30:32\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/html/start\",\"meta\":{\"title\":\"\",\"date\":\"2024-10-29 20:10:45\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/html/适配\",\"meta\":{\"title\":\"\",\"date\":\"2024-10-29 20:30:15\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/js/eventLoop\",\"meta\":{\"title\":\"\",\"date\":\"2024-10-29 20:20:37\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/js/promise\",\"meta\":{\"title\":\"\",\"date\":\"2024-10-29 20:21:07\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/js/this\",\"meta\":{\"title\":\"this 绑定\",\"date\":\"2025-03-11 14:52:01\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-10-29 20:10:52\\n * @LastEditT\",\"cover\":\"\"}},{\"route\":\"/basic/js/函数式编程\",\"meta\":{\"title\":\"\",\"date\":\"2024-10-29 20:17:52\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/js/原型\",\"meta\":{\"title\":\"构造函数\",\"date\":\"2024-10-29 20:22:02\",\"tag\":[],\"description\":\"在掌握原型之前，请读者务必先掌握JS中的数据类型。\\n 构造函数\\n一些读者可能对于面向类的语言有一定了解，导致混淆一些概念，但是JS中并没有类的固有概念，只是有类似的语法，如`new`和`instanc\",\"cover\":\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cbd22880ab847e09171559adf63c4ee~tplv-k3u1fbpfcp-watermark.image?\"}},{\"route\":\"/basic/js/闭包\",\"meta\":{\"title\":\"\",\"date\":\"2024-10-29 20:20:13\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/network/basic\",\"meta\":{\"title\":\"**Cookies 的作用**\",\"date\":\"2025-03-21 14:06:41\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2025-03-11 14:54:35\\n * @LastEditT\",\"cover\":\"\"}},{\"route\":\"/basic/npm/install\",\"meta\":{\"title\":\"npm安装依赖报错\",\"date\":\"2024-12-04 18:37:24\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-11-21 14:12:29\\n * @LastEditT\",\"cover\":\"/assets/npm-error.EApk1dtX.png\"}},{\"route\":\"/basic/npm/node\",\"meta\":{\"title\":\"\",\"date\":\"2025-02-22 10:03:01\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-12-02 19:31:11\\n * @LastEditT\",\"cover\":\"\"}},{\"route\":\"/basic/ts/start\",\"meta\":{\"title\":\"\",\"date\":\"2024-12-04 19:24:53\",\"tag\":[],\"description\":\"\",\"cover\":\"\"}},{\"route\":\"/basic/设计模式/start\",\"meta\":{\"title\":\"几个问题\",\"date\":\"2024-12-26 17:38:32\",\"tag\":[],\"description\":\"几个问题\\n 动态类型语言与静态类型语言的区别\\n 面向接口编程和面向实现编程的区别\\n 多态含义 js需要多态吗？\\n\\n&gt; 对象，又可以表示 Chicken 类型的对象，这意味着 JavaScript\",\"cover\":\"\"}},{\"route\":\"/basic/面试/cv\",\"meta\":{\"title\":\"简历编写指南\",\"date\":\"2025-01-04 18:00:31\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-12-27 10:54:18\\n * @LastEditT\",\"cover\":\"\"}},{\"route\":\"/vue/vue-router/01-start\",\"meta\":{\"title\":\"vue-router\",\"date\":\"2024-09-20 16:25:03\",\"tag\":[],\"description\":\"关于vue-router的使用官方文档上介绍的非常详细，这里主要从源码的角度来探究`vue-router`到底是如何实现将视图与路径结合起来。\\n vue-router的使用流程\\n1. 注册路由插件 i\",\"cover\":\"\"}},{\"route\":\"/vue/vue-router/02-注册路由\",\"meta\":{\"title\":\"Vue.use\",\"date\":\"2024-09-20 16:24:58\",\"tag\":[],\"description\":\"使用vue-router的第一步是注册路由插件`Vue.use(VueRouter)`，Vue 提供了 Vue.use 的全局 API 来注册插件，定义在 vue/src/core/global-ap\",\"cover\":\"\"}},{\"route\":\"/vue/vue-router/03-VueRouter对象\",\"meta\":{\"title\":\"VueRouter 对象\",\"date\":\"2024-09-20 16:25:38\",\"tag\":[],\"description\":\"VueRouter 的实现是一个类，定义在 src/index.js 中，先看下它的构造函数\\n```js\\nconstructor (options: RouterOptions = {}) {\\n  t\",\"cover\":\"\"}},{\"route\":\"/vue/vue-router/04-matcher\",\"meta\":{\"title\":\"Matcher\",\"date\":\"2024-09-20 16:25:43\",\"tag\":[],\"description\":\"matcher的作用主要是维护当前系统路由，通过 matcher 的 match 方法可以找到匹配的路径 Route，作用于 Route 的切换和组件渲染。\\n`matcher` 相关的实现都在 `sr\",\"cover\":\"\"}},{\"route\":\"/vue/vue-router/05-transition-to\",\"meta\":{\"title\":\"transitionTo\",\"date\":\"2024-09-20 16:25:49\",\"tag\":[],\"description\":\"`history.transitionTo` 是 `Vue-Router` 中非常重要的方法，当我们切换路由线路的时候，就会执行到该方法，前一节我们分析了 `matcher `的相关实现，知道它是如何\",\"cover\":\"\"}},{\"route\":\"/vue/vue-router/06-problem\",\"meta\":{\"title\":\"problem\",\"date\":\"2024-09-20 16:26:10\",\"tag\":[],\"description\":\"TODO\",\"cover\":\"\"}},{\"route\":\"/vue/vue-router/07-mini-router\",\"meta\":{\"title\":\"mini-router\",\"date\":\"2024-09-20 16:26:46\",\"tag\":[],\"description\":\"TODO\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/01-start\",\"meta\":{\"title\":\"准备工作\",\"date\":\"2024-10-29 20:01:04\",\"tag\":[],\"description\":\"::: tip 介绍\\n1. 这是一个基于vue2.6版本的源码分析。为什么在目前vue3已经较为普及的环境下，仍然去更新vue2的源码分析呢？一方面呢&lt;br\\n:::\\n 前置准备\\n拉取代码\\n```\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/02-init\",\"meta\":{\"title\":\"初始化\",\"date\":\"2024-09-20 14:10:51\",\"tag\":[],\"description\":\"初始化\\n这篇主要分析一下`Vue`的初始化过程，当我们引用构建文件或者使用脚手架构建项目后，入口文件会创建一个`Vue`实例，前提是执行了`import Vue from 'vue'`后（初始化Vue\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/03-mount\",\"meta\":{\"title\":\"挂载\",\"date\":\"2024-09-20 14:31:20\",\"tag\":[],\"description\":\"mount\\n在上一篇Vue初始化结束后，调用了`vm.$mount()`挂载`dom`，渲染页面。但是现在为止，只分析了`Vue`的初始化过程，还未分析初始化后是如何挂载dom的。下面是初始化的最后检\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/04-render\",\"meta\":{\"title\":\"render\",\"date\":\"2024-09-20 17:20:48\",\"tag\":[],\"description\":\"vm._render()\\n它的作用就是把实例渲染成虚拟节点`vnode`，定义在`src/core/instance/render.js`文件中。\\n```js\\nVue.prototype._rende\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/05-update\",\"meta\":{\"title\":\"vm._update()\",\"date\":\"2024-09-20 14:34:53\",\"tag\":[],\"description\":\"vm._update()\\n 作用\\n将虚拟`Dom`渲染成真实`Dom`。\\n 时机\\n它会在两个时机调用，即首次渲染和数据更新。\\n目前还在分析首次渲染阶段，先不看数据更新。复习在 mount一节中提到挂载\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/06-firstRender\",\"meta\":{\"title\":\"首次渲染\",\"date\":\"2024-09-20 14:36:44\",\"tag\":[],\"description\":\"首次渲染\\n前面铺垫了这么多，介绍了`Vue`的初始化，包括实例成员初始化，静态成员初始化，以及平台相关的内容，`render`函数生成，执行`update`挂载`Dom`树，内容很多，需要先停下来梳理\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/07-virtualDom\",\"meta\":{\"title\":\"虚拟 Dom\",\"date\":\"2024-09-20 15:07:53\",\"tag\":[],\"description\":\"定义\\n官方文档中的定义非常精炼：\\n\\n 目的\\n虚拟dom在不同框架中使用的特点包括\\n1. 避免直接操作dom 提高开发效率\\n2. 作为一个中间层可以跨平台\\n3. 虚拟dom不一定能提高性能\\n  - 首次\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/08-reactive\",\"meta\":{\"title\":\"reactive\",\"date\":\"2023-01-05 16:00:00\",\"tags\":[\"reactive\"],\"categories\":[\"vue2\"],\"tag\":[\"vue2\",\"reactive\"],\"description\":\"响应式\\n响应式原理是`Vue`的重中之重，也是`MVVM`的核心。一些基础的内容通过官方文档即可获知，这里将更注重对于源码的探索和一些场景的思考，例如数组的响应式处理。\\n Object.defineP\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/09-array-reactive\",\"meta\":{\"title\":\"数组的响应式处理\",\"date\":\"2024-09-20 15:18:22\",\"tag\":[],\"description\":\"前面在响应式一节，关于数组的处理当时没有着重分析，在文件`src/core/observer/index.js`中，入口如下：\\n```js\\n  constructor(value: any) {\\n  \",\"cover\":\"\"}},{\"route\":\"/vue/vue2/10-watcher\",\"meta\":{\"title\":\"watcher\",\"date\":\"2024-09-20 15:21:58\",\"tag\":[],\"description\":\"经常会提到`computed`和`watch`的原理是什么，因此这里单独说明 `Vue`源码中 `watcher` 相关内容。在源码中，分为三类 `watcher`：\\n- 渲染 `watcher`\\n-\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/11-nexttick\",\"meta\":{\"title\":\"nextTick\",\"date\":\"2024-09-20 15:26:10\",\"tag\":[],\"description\":\"nextTick\\nnextTick是一个开发中经常会用到的一个api，正因为经常使用，所以也是面试高频考点。它的用法最核心的一句话就是将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/12-component\",\"meta\":{\"title\":\"组件化\",\"date\":\"2024-09-20 15:45:09\",\"tag\":[],\"description\":\"在进行源码分析前，就强调了vue.js的核心思想就是组件化。在实际开发过程中，我们会将页面拆分成多个组件，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。不过如果不理\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/13-component-create\",\"meta\":{\"title\":\"组件创建\",\"date\":\"2024-09-20 15:50:14\",\"tag\":[],\"description\":\"首先要强调的一点是：这里的组件创建不是创建组件的构造函数，创建组件的构造函数是在组件注册中完成的，而是创建组件`vnode`。\\n 开始创建组件的时机\\n当已经完成组件注册后，等到创建`vnode`时，执\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/14-patch\",\"meta\":{\"title\":\"patch\",\"date\":\"2024-09-20 15:52:51\",\"tag\":[],\"description\":\"通过`createComponent` 创建了组件 `VNode`，之后将调用`vm._update()`，执行`patch`将`vnode`变成真正的节点，`patch` 的过程会调用 `creat\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/15-merge-option\",\"meta\":{\"title\":\"合并配置\",\"date\":\"2024-09-20 15:56:50\",\"tag\":[],\"description\":\"new Vue的场景有两个，一个是主动调用new Vue(options) 的方式实例化一个 Vue 对象；另一种组件创建过程中内部通过 new Vue(options) 实例化子组件Sub。它们都会\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/16-lifecycle\",\"meta\":{\"title\":\"生命周期钩子函数\",\"date\":\"2024-09-20 15:59:56\",\"tag\":[],\"description\":\"生命周期钩子函数\\n在实际开发中，我们经常与生命周期函数打交道，但是有时候总会遇到各种执行顺序的问题，或者获取不到数据。不过如果掌握了生命周期钩子函数如何执行的原理，这些问题就会不攻自破。\\n 源码定义\\n\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/17-component-register\",\"meta\":{\"title\":\"组件注册\",\"date\":\"2024-09-20 15:49:02\",\"tag\":[],\"description\":\"一个vue组件在使用前需要先被注册，这样vue才能在渲染模板时找到其对应的实现。组件注册的类型有全局注册和局部注册。\\n 全局注册\\n 使用\\n要注册一个全局组件，可以使用 Vue.component(ta\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/18-async-component\",\"meta\":{\"title\":\"异步组件\",\"date\":\"2024-09-20 15:51:06\",\"tag\":[],\"description\":\"在vue中，支持了异步组件\\n```js\\nVue.component('async-example', function (resolve, reject) {\\n   // 这个特殊的 require \",\"cover\":\"\"}},{\"route\":\"/vue/vue2/19-keep-alive\",\"meta\":{\"title\":\"keep-alive关注点\",\"date\":\"2024-09-20 16:22:03\",\"tag\":[],\"description\":\"1. props\\n2. keep-alive 组件自身渲染\\n3. keep-alive 包裹的组件渲染\\n keep-alive自身渲染\\n设置了`abstract`为`true`，说明这个组件是不用真正\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/20-extend-v-model\",\"meta\":{\"title\":\"v-model\",\"date\":\"2024-09-20 16:20:18\",\"tag\":[],\"description\":\"vue提供了一些好用的extend，比如keep-alive，slot，transition等等，使用频率也非常高。但是在使用过程中，往往会出现我们以为的bug，所以这一节有必要分析一下extend中\",\"cover\":\"\"}},{\"route\":\"/vue/vue2/index\",\"meta\":{\"hidden\":true,\"readingTime\":false,\"date\":\"2024-09-20 17:16:54\",\"author\":false,\"recommend\":false,\"title\":\"vue2源码阅读\",\"tag\":[],\"description\":\"vue2源码阅读\\n 准备工作\\n- 准备源码\\n 数据驱动\\n- 初始化\\n- 挂载dom\\n- render\\n- update\\n- 首次渲染\\n- 虚拟dom\\n 虚拟DOM\\n- 虚拟DOM\\n 响应式\\n- 响应式\",\"cover\":\"\"}},{\"route\":\"/vue/vue3/01-reactive\",\"meta\":{\"title\":\"vue3 响应式\",\"date\":\"2025-05-16 15:30:58\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2024-11-17 16:16:34\\n * @LastEditT\",\"cover\":\"/assets/reactive-constructure.-Ja5GmCF.png\"}},{\"route\":\"/vue/vue3/02-reactive\",\"meta\":{\"title\":\"原始值的响应式方案\",\"date\":\"2025-05-21 17:09:05\",\"tag\":[],\"description\":\"&lt;!--\\n * @Description:\\n * @version:\\n * @Author: Murphy\\n * @Date: 2025-05-21 17:02:42\\n * @LastEditT\",\"cover\":\"\"}}],\"search\":true,\"footer\":{\"copyright\":\"MIT License | Murphy\"},\"themeColor\":\"el-blue\",\"author\":\"Murphy\",\"friend\":[{\"nickname\":\"Vitepress\",\"des\":\"Vite & Vue Powered Static Site Generator\",\"avatar\":\"https://vitepress.dev/vitepress-logo-large.webp\",\"url\":\"https://vitepress.dev/\"}],\"hotArticle\":{\"title\":\"🔥 精选文章\",\"nextText\":\"换一组\",\"pageSize\":9,\"empty\":\"暂无精选内容\"},\"recommend\":false,\"comment\":{\"repo\":\"murph-1999/murph-1999.github.io\",\"repoId\":\"MDEwOlJlcG9zaXRvcnkyNDY1MTEyOTQ=\",\"category\":\"Announcements\",\"categoryId\":\"DIC_kwDODrF2vs4CgAF8\",\"inputPosition\":\"top\"},\"mermaid\":false},\"sidebar\":{\"/basic/js/\":[{\"text\":\"基础\",\"collapsed\":false,\"items\":[{\"text\":\"this绑定\",\"link\":\"/basic/js/this\"}]}],\"/basic/ts/\":[{\"text\":\"基础\",\"collapsed\":false,\"items\":[{\"text\":\"ts\",\"link\":\"/basic/js/start\"}]}],\"/basic/css/\":[{\"text\":\"css\",\"collapsed\":false,\"items\":[{\"text\":\"CSS基础\",\"link\":\"/basic/css/start\"}]}],\"/basic/html/\":[{\"text\":\"html\",\"collapsed\":false,\"items\":[{\"text\":\"适配问题\",\"link\":\"/basic/html/适配\"}]}],\"/basic/es6/\":[{\"text\":\"es6基础\",\"collapsed\":false,\"items\":[{\"text\":\"es6基础\",\"link\":\"/basic/es6/start\"}]}],\"/basic/npm/\":[{\"text\":\"npm\",\"collapsed\":false,\"items\":[{\"text\":\"npm安装依赖报错\",\"link\":\"/basic/npm/install\"}]}],\"/basic/deploy/\":[{\"text\":\"nginx\",\"collapsed\":false,\"items\":[{\"text\":\"nginx常用命令\",\"link\":\"/basic/deploy/nginx\"}]}],\"/explore/\":[{\"text\":\"Explore\",\"collapsed\":false,\"items\":[{\"text\":\"Nexus\",\"link\":\"/explore/nexus\"},{\"text\":\"构建多页面应用\",\"link\":\"/explore/vue-cli-pages\"},{\"text\":\"微前端方案\",\"link\":\"/explore/micro-frontend\"},{\"text\":\"换肤方案\",\"link\":\"/explore/change-skin\"},{\"text\":\"性能优化\",\"link\":\"/explore/performance-optimization\"},{\"text\":\"自定义级联组件\",\"link\":\"/explore/vue-el-cascader\"}]}],\"/build/\":[{\"text\":\"Webpack\",\"collapsed\":false,\"items\":[{\"text\":\"Webpack基础\",\"link\":\"/build/webpack\"},{\"text\":\"Webpack构建优化\",\"link\":\"/build/optimize\"}]},{\"text\":\"Vite\",\"collapsed\":false,\"items\":[]}],\"/vue/\":[{\"text\":\"准备工作\",\"collapsed\":false,\"items\":[{\"text\":\"准备源码\",\"link\":\"/vue/vue2/01-start\"}]},{\"text\":\"数据驱动\",\"collapsed\":false,\"items\":[{\"text\":\"初始化\",\"link\":\"/vue/vue2/02-init\"},{\"text\":\"挂载dom\",\"link\":\"/vue/vue2/03-mount\"},{\"text\":\"render\",\"link\":\"/vue/vue2/04-render\"},{\"text\":\"update\",\"link\":\"/vue/vue2/05-update\"},{\"text\":\"首次渲染\",\"link\":\"/vue/vue2/06-firstRender\"}]},{\"text\":\"虚拟DOM\",\"collapsed\":false,\"items\":[{\"text\":\"虚拟DOM\",\"link\":\"/vue/vue2/07-virtualDom\"}]},{\"text\":\"响应式\",\"collapsed\":false,\"items\":[{\"text\":\"响应式\",\"link\":\"/vue/vue2/08-reactive\"},{\"text\":\"数组的响应式\",\"link\":\"/vue/vue2/09-array-reactive\"},{\"text\":\"watcher\",\"link\":\"/vue/vue2/10-watcher\"},{\"text\":\"nexttick\",\"link\":\"/vue/vue2/11-nexttick\"}]},{\"text\":\"组件化\",\"collapsed\":false,\"items\":[{\"text\":\"准备工作\",\"link\":\"/vue/vue2/12-component/\"},{\"text\":\"组件创建\",\"link\":\"/vue/vue2/13-component-create\"},{\"text\":\"patch\",\"link\":\"/vue/vue2/14-patch\"},{\"text\":\"merge-option\",\"link\":\"/vue/vue2/15-merge-option\"},{\"text\":\"生命周期\",\"link\":\"/vue/vue2/16-lifecycle\"},{\"text\":\"组件注册\",\"link\":\"/vue/vue2/17-component-register\"},{\"text\":\"异步组件\",\"link\":\"/vue/vue2/18-async-component\"}]},{\"text\":\"扩展\",\"collapsed\":false,\"items\":[{\"text\":\"keep-alive\",\"link\":\"/vue/vue2/19-keep-alive/\"},{\"text\":\"extend-v-model\",\"link\":\"/vue/vue2/20-extend-v-model\"}]},{\"text\":\"vue-router\",\"collapsed\":false,\"items\":[{\"text\":\"准备工作\",\"link\":\"/vue/vue-router/01-start\"},{\"text\":\"注册路由\",\"link\":\"/vue/vue-router/02-注册路由\"},{\"text\":\"VueRouter对象\",\"link\":\"/vue/vue-router/03-VueRouter对象\"},{\"text\":\"matcher\",\"link\":\"/vue/vue-router/04-matcher\"},{\"text\":\"transition-to\",\"link\":\"/vue/vue-router/05-transition-to\"},{\"text\":\"problem\",\"link\":\"/vue/vue-router/06-problem\"},{\"text\":\"mini-router\",\"link\":\"/vue/vue-router/07-mini-router\"}]}]},\"outline\":{\"level\":[2,3],\"label\":\"目录\"},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"相关文章\",\"lastUpdated\":{\"Text\":\"上次更新于\"},\"logo\":\"/img/icon.png\",\"nav\":[{\"text\":\"基础知识汇总\",\"items\":[{\"text\":\"js\",\"link\":\"/basic/js/this\"},{\"text\":\"css\",\"link\":\"/basic/css/start\"},{\"text\":\"html\",\"link\":\"/basic/html/start\"},{\"text\":\"es6\",\"link\":\"/basic/es6/start\"},{\"text\":\"ts\",\"link\":\"/basic/ts/start\"},{\"text\":\"npm\",\"link\":\"/basic/npm/install\"},{\"text\":\"部署\",\"link\":\"/basic/deploy/nginx\"}]},{\"text\":\"vue\",\"items\":[{\"text\":\"vue2源码\",\"link\":\"/vue/\"},{\"text\":\"vue3源码\",\"link\":\"/vue/\"}]},{\"text\":\"自动化构建\",\"link\":\"/build/webpack\"},{\"text\":\"Explore\",\"link\":\"/explore/nexus\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/murph-1999\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>