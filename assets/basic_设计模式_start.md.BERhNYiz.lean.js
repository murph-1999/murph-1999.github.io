import{_ as o,o as r,c as i,I as s,w as t,a,j as e,a8 as n,D as p}from"./chunks/framework.Q0X2mdF-.js";const nl=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"basic/设计模式/start.md","filePath":"basic/设计模式/start.md","lastUpdated":null}'),c={name:"basic/设计模式/start.md"},h=n("",82),d=n("",12),u=e("h4",{id:"必须先订阅再发布吗",tabindex:"-1"},[a("必须先订阅再发布吗 "),e("a",{class:"header-anchor",href:"#必须先订阅再发布吗","aria-label":'Permalink to "必须先订阅再发布吗"'},"​")],-1),b=e("p",null,"不一定，因为受一些不确定的因素影响，比如异步消息返回的比较快，也就是已经发布了信息，但是订阅者还未来得及订阅，特别使用了一些模块化惰性加载的时候，",-1),_={id:"js实现发布订阅模式的便利性",tabindex:"-1"},g=e("a",{class:"header-anchor",href:"#js实现发布订阅模式的便利性","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">js实现发布订阅模式的便利性</font>"'},"​",-1),f={id:"发布订阅模式的缺点",tabindex:"-1"},y=e("a",{class:"header-anchor",href:"#发布订阅模式的缺点","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">发布订阅模式的缺点</font>"'},"​",-1),k={id:"创建订阅者本身要消耗一定的时间和内存-而",tabindex:"-1"},m=e("a",{class:"header-anchor",href:"#创建订阅者本身要消耗一定的时间和内存-而","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">创建订阅者本身要消耗一定的时间和内存，而 </font>"'},"​",-1),x=e("h3",{id:"命令模式",tabindex:"-1"},[a("命令模式 "),e("a",{class:"header-anchor",href:"#命令模式","aria-label":'Permalink to "命令模式"'},"​")],-1),P=e("h4",{id:"定义-5",tabindex:"-1"},[a("定义 "),e("a",{class:"header-anchor",href:"#定义-5","aria-label":'Permalink to "定义"'},"​")],-1),q=e("h4",{id:"js中的命令模式",tabindex:"-1"},[a("js中的命令模式 "),e("a",{class:"header-anchor",href:"#js中的命令模式","aria-label":'Permalink to "js中的命令模式"'},"​")],-1),E=e("p",null,"命令模式的由来，其实是回调函数的一个面向对象的替代品",-1),v=e("p",null,"js作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到js中，因为函数作为一等公民（对象），本身就可以被四处传递，可作为参数传入，可返回。",-1),F=e("p",null,"因此可以使用闭包的方式来实现",-1),j=e("h4",{id:"可定义的行为",tabindex:"-1"},[a("可定义的行为 "),e("a",{class:"header-anchor",href:"#可定义的行为","aria-label":'Permalink to "可定义的行为"'},"​")],-1),C=n("",7),A=e("h4",{id:"宏命令",tabindex:"-1"},[a("宏命令 "),e("a",{class:"header-anchor",href:"#宏命令","aria-label":'Permalink to "宏命令"'},"​")],-1),S={id:"智能模式与傻瓜命令",tabindex:"-1"},T=e("a",{class:"header-anchor",href:"#智能模式与傻瓜命令","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">智能模式与傻瓜命令</font>"'},"​",-1),D=e("h3",{id:"组合模式",tabindex:"-1"},[a("组合模式 "),e("a",{class:"header-anchor",href:"#组合模式","aria-label":'Permalink to "组合模式"'},"​")],-1),B=e("h4",{id:"定义-6",tabindex:"-1"},[a("定义 "),e("a",{class:"header-anchor",href:"#定义-6","aria-label":'Permalink to "定义"'},"​")],-1),O=n("",6),I={id:"需要注意的地方",tabindex:"-1"},V=e("a",{class:"header-anchor",href:"#需要注意的地方","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">需要注意的地方</font>"'},"​",-1),J=e("ul",null,[e("li",null,"组合对象与叶对象具有相同的接口"),e("li",null,"对一组叶对象的操作必须具有一致性")],-1),N={start:"3"},R={id:"在组合模式中使用职责链",tabindex:"-1"},w=e("a",{class:"header-anchor",href:"#在组合模式中使用职责链","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">在组合模式中使用职责链</font>"'},"​",-1),U=e("ul",null,[e("li",null,"[ ] 一个删除文件夹的例子，结合职责链来实现！")],-1),$=e("h4",{id:"组合模式的优缺点",tabindex:"-1"},[a("组合模式的优缺点 "),e("a",{class:"header-anchor",href:"#组合模式的优缺点","aria-label":'Permalink to "组合模式的优缺点"'},"​")],-1),M=e("ol",null,[e("li",null,"优点")],-1),L={start:"2"},Q={id:"模板方法模式",tabindex:"-1"},W=e("a",{class:"header-anchor",href:"#模板方法模式","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">模板方法模式</font>"'},"​",-1),Z={id:"定义-7",tabindex:"-1"},z=e("a",{class:"header-anchor",href:"#定义-7","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">定义</font>"'},"​",-1),G={id:"组成",tabindex:"-1"},H=e("a",{class:"header-anchor",href:"#组成","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">组成</font>"'},"​",-1),K={id:"抽象类",tabindex:"-1"},X=e("a",{class:"header-anchor",href:"#抽象类","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">抽象类</font>"'},"​",-1),Y=e("p",null,"模板方法模式严重依赖抽象类，js在语言层面上并没有提供对抽象类的支持。",-1),aa={id:"使用场景",tabindex:"-1"},la=e("a",{class:"header-anchor",href:"#使用场景","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">使用场景</font>"'},"​",-1),sa={id:"钩子方法",tabindex:"-1"},ea=e("a",{class:"header-anchor",href:"#钩子方法","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">钩子方法</font>"'},"​",-1),ta={id:"好莱坞原则",tabindex:"-1"},na=e("a",{class:"header-anchor",href:"#好莱坞原则","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">好莱坞原则</font>"'},"​",-1),oa=e("p",null,"这三个都符合好莱坞原则",-1),ra=e("h4",{id:"js中真的需要继承吗",tabindex:"-1"},[a("js中真的需要继承吗 "),e("a",{class:"header-anchor",href:"#js中真的需要继承吗","aria-label":'Permalink to "js中真的需要继承吗"'},"​")],-1),ia=e("h3",{id:"亨元模式",tabindex:"-1"},[a("亨元模式 "),e("a",{class:"header-anchor",href:"#亨元模式","aria-label":'Permalink to "亨元模式"'},"​")],-1),pa=e("h4",{id:"定义-8",tabindex:"-1"},[a("定义 "),e("a",{class:"header-anchor",href:"#定义-8","aria-label":'Permalink to "定义"'},"​")],-1),ca={id:"内部状态和外部状态",tabindex:"-1"},ha=e("a",{class:"header-anchor",href:"#内部状态和外部状态","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">内部状态和外部状态</font>"'},"​",-1),da=e("h4",{id:"通用结构",tabindex:"-1"},[a("通用结构 "),e("a",{class:"header-anchor",href:"#通用结构","aria-label":'Permalink to "通用结构"'},"​")],-1),ua=e("ol",null,[e("li",null,"只有当某种共享对象被真正需要时，它才从工厂中被创建出来"),e("li",null,"当外部状态非常复杂时，他们与共享对象的联系会变得十分困难，因此将使用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子与共享对象联系起来。")],-1),ba=e("h4",{id:"使用场景-1",tabindex:"-1"},[a("使用场景 "),e("a",{class:"header-anchor",href:"#使用场景-1","aria-label":'Permalink to "使用场景"'},"​")],-1),_a={id:"没有内部状态的亨元和没有外部状态的亨元",tabindex:"-1"},ga=e("a",{class:"header-anchor",href:"#没有内部状态的亨元和没有外部状态的亨元","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">没有内部状态的亨元和没有外部状态的亨元</font>"'},"​",-1),fa=n("",1),ya={id:"对象池技术",tabindex:"-1"},ka=e("a",{class:"header-anchor",href:"#对象池技术","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">对象池技术</font>"'},"​",-1),ma={id:"职责链模式",tabindex:"-1"},xa=e("a",{class:"header-anchor",href:"#职责链模式","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">职责链模式</font>"'},"​",-1),Pa={id:"定义-9",tabindex:"-1"},qa=e("a",{class:"header-anchor",href:"#定义-9","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">定义</font>"'},"​",-1),Ea={id:"灵活可拆分的职责链节点",tabindex:"-1"},va=e("a",{class:"header-anchor",href:"#灵活可拆分的职责链节点","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">灵活可拆分的职责链节点</font>"'},"​",-1),Fa={id:"异步的职责链",tabindex:"-1"},ja=e("a",{class:"header-anchor",href:"#异步的职责链","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">异步的职责链</font>"'},"​",-1),Ca=e("h4",{id:"职责链模式的优缺点",tabindex:"-1"},[a("职责链模式的优缺点 "),e("a",{class:"header-anchor",href:"#职责链模式的优缺点","aria-label":'Permalink to "职责链模式的优缺点"'},"​")],-1),Aa=e("p",null,"优点：",-1),Sa=e("li",null,"解耦了请求发送者和n个接受者之间的复杂关系",-1),Ta={start:"3"},Da={id:"用aop实现职责链",tabindex:"-1"},Ba=e("a",{class:"header-anchor",href:"#用aop实现职责链","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">用Aop实现职责链</font>"'},"​",-1),Oa=e("p",null,"结合AOP，叠加了函数的作用域，虽然把函数叠加在一起，但如果链条太长的话，可能会对性能造成影响。",-1),Ia=e("h4",{id:"应用-1",tabindex:"-1"},[a("应用 "),e("a",{class:"header-anchor",href:"#应用-1","aria-label":'Permalink to "应用"'},"​")],-1),Va={id:"中介者模式",tabindex:"-1"},Ja=e("a",{class:"header-anchor",href:"#中介者模式","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">中介者模式</font>"'},"​",-1),Na=e("h4",{id:"定义-10",tabindex:"-1"},[a("定义 "),e("a",{class:"header-anchor",href:"#定义-10","aria-label":'Permalink to "定义"'},"​")],-1),Ra={id:"案例-1",tabindex:"-1"},wa=e("a",{class:"header-anchor",href:"#案例-1","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">案例</font>"'},"​",-1),Ua={id:"最少知识原则",tabindex:"-1"},$a=e("a",{class:"header-anchor",href:"#最少知识原则","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">最少知识原则</font>"'},"​",-1),Ma={id:"缺点",tabindex:"-1"},La=e("a",{class:"header-anchor",href:"#缺点","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">缺点</font>"'},"​",-1),Qa={id:"装饰者模式",tabindex:"-1"},Wa=e("a",{class:"header-anchor",href:"#装饰者模式","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">装饰者模式</font>"'},"​",-1),Za=n("",32),za={id:"js中的状态机",tabindex:"-1"},Ga=e("a",{class:"header-anchor",href:"#js中的状态机","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">js中的状态机</font>"'},"​",-1),Ha=n("",8);function Ka(Xa,Ya,al,ll,sl,el){const l=p("font");return r(),i("div",{"data-pagefind-body":!0},[h,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("的绝大部分语言都内置了迭代器。")]),_:1}),d,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("—")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("态发生改变时，所有依赖于它的对象都将得到通知。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("p",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("疑问点")]),_:1})])]),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布订阅模式和观察者模式有区别吗？")]),_:1})])])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("比较认同的解释是：")]),_:1}),s(l,{style:{color:"rgb(81, 87, 103)"}},{default:t(()=>[a("我的理解发布订阅模式和观察者模式本质是一样的，只不过名字不一样。这就好比你小名叫臭臭，身份证叫香香。二者都是为了解决一类共同的问题，都是为了收集注册的回调方法，到该触发的时机去执行。并不是多了个任务中心就不一样了，无非多几行代码的事，把代码再优化优化。就好比webpack执行loader所用的compose 函数，所以它仅仅是一种”代码实现方式”,也可被称为一种模式，")]),_:1}),a("**"),s(l,{style:{color:"rgb(81, 87, 103)"}},{default:t(()=>[a("因为模式这个东西本身是不存在编程语言中的，通俗地讲，设计模式可以理解为是为了解决具体的需求而出现的一种通用逻辑或者方案。")]),_:1}),a("**"),s(l,{style:{color:"rgb(81, 87, 103)"}},{default:t(()=>[a("举个例子:因为有疫情，怕接触感染。但我们需要找工作，公司也需要招员工，所以我们出现了线上面试应对这样的需求，而且它适合绝大部分求职者和公司。")]),_:1}),s(l,{style:{color:"rgb(81, 87, 103)"}},{default:t(()=>[a("所以我们可以把它理解为跟需求相匹配的一种解决问题的方式。二者完全可以认为是解决同一类型问题的方案，本质上没有任何区别！")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("所以还是按照书本中所说，发布订阅模式又叫观察者模式，只是我们要看不同的场景进行改动。")]),_:1}),u,b,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被 存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("QQ ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("的未读消息只会被重 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("新阅读一次，所以刚才的操作我们只能进行一次。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",_,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("js实现发布订阅模式的便利性")]),_:1}),a(),g]),e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("在js中，可以使用注册回调的形式")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("选择推模型（事件发生时，发布者一次性将所有更改的状态和数据都推送给订阅者），使用 Function.prototype.apply 方法把所有参数都推送给订阅者")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",f,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布订阅模式的缺点")]),_:1}),a(),y]),e("blockquote",null,[e("h4",k,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("创建订阅者本身要消耗一定的时间和内存，而 ")]),_:1}),a(),m]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("—")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("起的时候，要跟踪一个 bug 不是件轻松的事情。")]),_:1})]),x,P,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。")]),_:1}),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("设计模式的主题总是把不变的事物和变化的事物分离开来")]),_:1})])])]),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("而且js可以用高阶函数非常方便地实现命令模式，在js中是一种隐形模式")]),_:1})])])]),q,E,v,F,j,e("p",null,[a("命令模式的作用不仅是封装运算块，"),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("而且可以很方便地给命令对象增加撤销操作。就像订餐 时客人可以通过电话来取消订单一样。")]),_:1})]),C,s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("需要更改的地方，将当前的目标位置更改为步长")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),A,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。它是命令模式与组合模式的结合。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",S,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("智能模式与傻瓜命令")]),_:1}),a(),T]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("一般来说，命令模式都会在 command 对象中保存一个接收者来负责真正执行客户的请求，这种情况下命令对象是“傻瓜式”的，它只负责把客户的请求转交给接收者来执行，这种模式的好处是请求发起者和请求接收者之间尽可能地得到了解耦。 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("但是我们也可以定义一些更“聪明”的命令对象，“聪明”的命令对象可以直接实现请求， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("这样一来就不再需要接收者的存在，这种“聪明”的命令对象也叫作智能命令。没有接收者的智 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("能命令，退化到和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们意图 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("的不同。")]),_:1}),a("**"),s(l,{style:{color:"#597EF7"}},{default:t(()=>[a("策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标 ")]),_:1}),a("**"),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}},{default:t(()=>[a("的不同手段，它们的内部实现是针对“算法”而言的。而智能命令模式指向的问题域更广，")]),_:1}),a("****"),s(l,{style:{color:"#597EF7"}},{default:t(()=>[a("command ")]),_:1})])]),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}},{default:t(()=>[a("对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。")]),_:1})])]),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}})])]),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}})])]),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}})])]),D,B,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("小的“孙对象”构成的。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),O,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("JavaScript 中实现组合模式的难点在于要保证组合对象和叶对象对象拥有同样的方法，这通常需要用鸭子类型的思想对它们进行 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("接口检查。 在 JavaScript 中实现组合模式，看起来缺乏一些严谨性，我们的代码算不上安全，但能更快 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("速和自由地开发，这既是 JavaScript 的缺点，也是它的优点。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",I,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("需要注意的地方")]),_:1}),a(),V]),e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("组合模式不是父子关系")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对叶对象操作的一致性")]),_:1})])]),J,e("ol",N,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("当对象之间的关系并不是严格意义上的层次结构，不适用于使用组合模式")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("可以使用职责链模式提高组合模式性能？")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",R,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("在组合模式中使用职责链")]),_:1}),a(),w]),U,$,M,e("ul",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("表示对象的部分整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分整 ")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("式中增加和删除树的节点非常方便，并且符合开放")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("封闭原则。 ")]),_:1}),e("ul",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别， ")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("不用写一堆 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("if")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("、")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("else ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("这是组合模式最重要的能力。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("ol",L,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("缺点")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("如果系统中的每个对象看起来都和其他对象差不多，区别只有在运行的时候才能体现出来，那么就不适合用组合模式了。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h3",Q,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法模式")]),_:1}),a(),W]),e("h4",Z,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("定义")]),_:1}),a(),z]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("是一种基于继承的设计模式，")]),_:1}),a(),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语 言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改 动抽象父类以及其他子类，这也是符合开放封闭原则的。 但在 JavaScript 中，我们很多时候都不需要依样画瓢地去实现一个模版方法模式，高阶函数是更好的选择。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",G,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("组成")]),_:1}),a(),H]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("在一个例子中找到哪个是模板方法，")]),_:1}),a("**"),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法中会封装子类的算法框架")]),_:1}),a("**"),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",K,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("抽象类")]),_:1}),a(),X]),Y,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，当子类继承了这个抽象类时，必须重写父类的抽象方法。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("js中实现抽象类的缺点：无法保证子类会重写抽象类的方法，解决方案是可以使用鸭子类型判断或者在抽象方法中抛出异常")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",aa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("使用场景")]),_:1}),a(),la]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("在 Web 开发中也能找到很多模板方法模式的适用场景，比如我们在构建一系列的 UI 组件， 这些组件的构建过程一般如下所示： ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("(1) ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("初始化一个 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("div ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("容器； ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("(2) ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("通过 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("ajax ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("请求拉取相应的数据； ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("(3) ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("把数据渲染到 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("div ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("容器里面，完成组件的构造； ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("(4) 通知用户组件渲染完毕。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",sa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("钩子方法")]),_:1}),a(),ea]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("如果子类有异样的行为时，该如何区分呢？")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("钩子方法（hook）可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父 类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自 行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",ta,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("好莱坞原则")]),_:1}),a(),na]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("别调用我们，我们会调用你")]),_:1}),e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法模式")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布订阅模式")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("回调函数")]),_:1})])]),oa,ra,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("JavaScript 语言实际上没有提供真正的类式继承，继承是通过对象与对 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("象之间的委托来实现的。而模板方法模式是严重依赖于类的概念，所以这里使用js强行实现的模板方法模式并不正宗。")]),_:1}),ia,pa,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("从后面的例子可以看出，有多少中内部状态的组合，系统中便最多存在多少个共享对象。")]),_:1})]),a("__** **")])]),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。")]),_:1})])])]),s(l,{style:{color:"rgb(0,0,0)"}}),e("p",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("它是为了解决性能问题而生的问题")]),_:1})])]),e("h4",ca,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("内部状态和外部状态")]),_:1}),a(),ha]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("这是亨元模式的构成")]),_:1}),e("ul",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("内部状态存储于对象内部。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("内部状态可以被一些对象共享。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("内部状态独立于具体的场景，通常不会改变。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),da,ua,ba,e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("一个程序中使用了大量的相似对象。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("由于使用了大量对象，造成很大的内存开销。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对象的大多数状态")]),_:1}),a("**"),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("都可以变为外部状态。 ")]),_:1}),a("**")]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("文件上传就是一个很适合的例子")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",_a,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("没有内部状态的亨元和没有外部状态的亨元")]),_:1}),a(),ga]),fa,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("生产共享对象的工厂实际上变成了一个单例工厂。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",ya,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对象池技术")]),_:1}),a(),ka]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对象池维 护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如 果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入池子等待被下次获取。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("很多空间和时间都消耗在了 DOM 节点上，如何避免频繁地创建和删除 DOM 节点就成了一个有意义的话题。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对象池与亨元模式类似，但它并没有主动分离内部状态和外部状态的过程。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h3",ma,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("职责链模式")]),_:1}),a(),xa]),e("h4",Pa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("定义")]),_:1}),a(),qa]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Ea,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("灵活可拆分的职责链节点")]),_:1}),a(),va]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("让链中的各个节点可以灵活拆分和重组")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Fa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("异步的职责链")]),_:1}),a(),ja]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("使用场景是：节点函数中发起一个 ajax异步请求，异步请求返回的结果才能决定是否继续在职责链中 passRequest")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),Ca,Aa,e("ol",null,[Sa,e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("链中的节点对象可以灵活地拆分重组。增加或者删除一个节 ")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("点，或者改变节点在链中的位置都是轻而易举的事情。")]),_:1}),e("ol",Ta,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("可以手动指定起始节点")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("缺点：")]),_:1}),e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("不能保证某个请求一定会被链中的节点处理。当请求得不到答复时，就会径直从链尾离开，或者抛 出一个错误异常。在这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离 开链尾的请求。")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分 节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避 免过长的职责链带来的性能损耗。")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Da,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("用Aop实现职责链")]),_:1}),a(),Ba]),Oa,Ia,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("无论是作用域链、原型链，还是 DOM 节点中的事件冒泡，我们都能从中找到职责链模式的 影子。职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("效率。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h3",Va,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("中介者模式")]),_:1}),a(),Ja]),Na,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知 中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。使网状的多对多关系变成相对简单的一对多关系。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Ra,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("案例")]),_:1}),a(),wa]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("当节点对象都是耦合在一块时，一个节点的修改会造成多个节点的修改。改变或者增加任何一个节点对象，都要通知到与其相关的对象。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Ua,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("最少知识原则")]),_:1}),a(),$a]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("中介者模式符合最少知识原则，是指一个对象应 该尽可能少地了解另外的对象（类似不和陌生人说话）。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他的对象。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Ma,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("缺点")]),_:1}),a(),La]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("系统中要新增一个中介者对象，转移到中介者对象的复杂性")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h3",Qa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("装饰者模式")]),_:1}),a(),Wa]),Za,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("求委托给这些类来执行。 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("它们之间的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",za,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("js中的状态机")]),_:1}),a(),Ga]),Ha])}const ol=o(c,[["render",Ka]]);export{nl as __pageData,ol as default};
