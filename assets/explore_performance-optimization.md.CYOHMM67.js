import{_ as e,o as i,c as t,a8 as l}from"./chunks/framework.Q0X2mdF-.js";const s="/assets/performance-index.DdqhCHts.png",E=JSON.parse('{"title":"性能优化","description":"","frontmatter":{},"headers":[],"relativePath":"explore/performance-optimization.md","filePath":"explore/performance-optimization.md","lastUpdated":null}'),o={name:"explore/performance-optimization.md"},r=l(`<h1 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h1><hr><h3 id="一、加载性能优化" tabindex="-1">一、加载性能优化 <a class="header-anchor" href="#一、加载性能优化" aria-label="Permalink to &quot;一、加载性能优化&quot;">​</a></h3><ol><li><p><strong>代码分割与懒加载</strong></p><ul><li><strong>原理</strong>：利用 <code>Webpack</code> 动态导入 (<code>import()</code>) 或框架路由懒加载（如 React.lazy、Vue 异步组件）。 【把代码分离到不同的bundle中，然后按需加载或并行加载文件 用于获取更小的bundle，控制资源加载优先级 ● 入口起点：使用 entry 配置手动地分离代码。 ○ 如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。 ○ 这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。 ● 防止重复：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。 ● 动态导入：通过模块的内联函数调用来分离代码。动态导入一个模块时，模块会分离到一个单独的bundle 】</li><li><strong>场景</strong>：例如首页仅加载首屏模块，其他详情页通过路由懒加载拆分，降低首屏体积。</li><li><strong>效果</strong>：首屏加载时间从 3s → 1.5s，FCP（首次内容渲染）提升 40%。</li></ul></li><li><p><strong>资源压缩与 CDN 加速</strong></p><ul><li><p><strong>实践</strong>：使用 <code>Webpack</code> 的 Terser 压缩 JS，<code>imagemin</code> 压缩图片，CSS 提取为独立文件并压缩 使用到webpack的打包优化，参考webpack优化的文章 TODO 减少请求数、减小请求资源体积、提升网络传输速率 压缩html，js，css 服务器上开启Gzip传输压缩（比如 vue打包后支持压缩体积，nginx可以开启gzip传输），它能将我们的文本类文件体积压缩至原先的四分之一 有时候ui提供的字体资源文件过大，高达几M，这时可以结合字体属性，使用字体分包，将字体文件分成按需加载的小份包，技术内幕【<a href="https://chinese-font.netlify.app/post/font_split_turbo/%E3%80%91" target="_blank" rel="noreferrer">https://chinese-font.netlify.app/post/font_split_turbo/】</a></p><p>nginx开启gzip，来压缩文本资源（HTML/CSS/JS），可以减少传输体积</p></li><li><p><strong>场景</strong>：官网项目静态资源非常多包括字体文件，图片等，静态资源上传至 CDN（如阿里云 OSS），通过 <code>dns-prefetch</code> 预解析域名。</p></li><li><p><strong>指标</strong>：资源体积减少 60%，CDN 加速后全球访问延迟降低 30%。</p></li></ul></li><li><p><strong>HTTP/2 与预加载</strong></p><ul><li><strong>策略</strong>：开启 HTTP/2 多路复用（和HTTP/1的区别和现象，nginx开启多路复用），使用 <code>preload</code> 加载关键字体/CSS，<code>preconnect</code> 预连接第三方域名。 详细可以查看nginx优化配置 ● preload 是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源； ● prefetch 是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源。预测会加载指定资源，如在我们的场景中，我们在页面加载后会初始化首屏组件，当用户滚动页面时，会拉取第二屏的组件，若能预测用户行为，则可以 prefetch 下一屏的组件。</li><li><strong>案例</strong>：新闻网站预加载首屏文章字体，避免 FOIT（字体未加载时的空白）。vue框架中是怎么做预加载<code>preload</code>的</li></ul></li><li><p>index.html中可以指定独立脚本文件</p></li><li><p>路由中可以设置路由懒加载</p></li><li><p>webpack配置哪些资源可以预加载或者懒加载（默认的配置可能会造成一些资源浪费，比如默认开启prefetch，而prefetch会加载将来可能不会使用到的资源，造成开屏很慢，如果你的应用很大且有很多 async chunk，而用户主要使用的是对带宽较敏感的移动端，那么你可能需要关掉 prefetch 链接并手动选择要提前获取的代码区块。） vue打包后js脚本默认为defer，原因如下：</p></li><li><p>优化加载性能：defer 可以让 JavaScript 文件异步加载，避免脚本阻塞页面的渲染。Vue 使用 Webpack 或 Vite 等构建工具打包时，会自动在打包后的 index.html 中为 JavaScript 文件添加 defer 属性，以提高页面加载性能。</p></li><li><p>避免阻塞渲染：如果没有 defer，浏览器会阻塞渲染，直到所有的脚本都下载并执行完毕，这会导致页面的首次渲染时间变长。使用 defer 可以确保页面渲染不会因为 JavaScript 文件的加载而延迟。</p></li><li><p>提高用户体验：通过延迟 JavaScript 的执行，Vue 可以更快地呈现页面的内容，用户可以更早看到页面的结构和样式，尽管某些动态行为（如交互）会稍后加载。</p></li></ol><hr><h3 id="二、渲染性能优化" tabindex="-1">二、渲染性能优化 <a class="header-anchor" href="#二、渲染性能优化" aria-label="Permalink to &quot;二、渲染性能优化&quot;">​</a></h3><ol><li><p><strong>减少重排与重绘</strong></p><ul><li><strong>技巧</strong>：使用 <code>transform</code> 替代 <code>top/left</code> 实现动画，通过 <code>will-change</code> 提示浏览器优化。 技巧补充（在css方面的优化）： <ol><li>图片在渲染前指定大小：因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小</li><li>多使用伪元素</li><li>字体图标？ 考点：重排和重绘的区别 重绘和重排 重排是由CPU处理的，而重绘是由GPU处理的，CPU的处理效率远不及GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。所以在性能优化工作中，我们更应当着重减少重排的发生。</li></ol></li><li><strong>场景</strong>：轮播图动画使用 <code>transform: translateX()</code>，避免频繁触发重排。</li><li><strong>工具</strong>：Chrome DevTools 的 Performance 面板分析渲染耗时。</li></ul></li><li><p><strong>虚拟列表 (Virtual List)</strong></p><ul><li><strong>原理</strong>：仅渲染可视区域内的列表项（如 <code>react-window</code>、<code>vue-virtual-scroller</code>）。</li><li><strong>场景</strong>：后台管理系统渲染 10,000 条数据时，DOM 节点从 10k → 20 个，内存占用减少 80%，遇到系统崩溃的情况，交易管理系统每个层级的数据级多达到千级甚至万级，比如账户级</li></ul></li><li><p><strong>防抖与节流</strong></p><ul><li><strong>应用</strong>：搜索框输入使用防抖（300ms 延迟请求），滚动事件监听使用节流。</li><li><strong>代码</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> debounceSearch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(keyword), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">input.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, debounceSearch);</span></span></code></pre></div></li></ul></li></ol><hr><h3 id="三、缓存策略" tabindex="-1">三、缓存策略 <a class="header-anchor" href="#三、缓存策略" aria-label="Permalink to &quot;三、缓存策略&quot;">​</a></h3><ol><li><p><strong>强缓存与协商缓存</strong></p><ul><li><strong>配置</strong>：Nginx 设置 <code>Cache-Control: max-age=31536000</code>（JS/CSS 强缓存），<code>Etag</code> 验证文件变更。</li><li><strong>效果</strong>：重复访问页面时，90% 的静态资源命中缓存，减少服务器压力。</li></ul></li><li><p><strong>Service Worker 离线缓存</strong></p><ul><li><strong>实现</strong>：使用 <code>Workbox</code> 预缓存关键资源，实现离线访问（PWA 应用）。</li><li><strong>场景</strong>：资讯类 App 离线缓存最新 10 篇文章，提升弱网用户体验。</li></ul></li></ol><hr><h3 id="四、框架级优化" tabindex="-1">四、框架级优化 <a class="header-anchor" href="#四、框架级优化" aria-label="Permalink to &quot;四、框架级优化&quot;">​</a></h3><ol><li><p><strong>React 优化</strong></p><ul><li><strong>Memoization</strong>：<code>React.memo</code> 缓存组件，<code>useMemo</code>/<code>useCallback</code> 避免重复计算。</li><li><strong>场景</strong>：表格组件在 props 未变化时跳过渲染，性能提升 50%。</li></ul></li><li><p><strong>Vue 优化</strong></p><ul><li><strong>v-once</strong>：静态内容标记 <code>v-once</code>，避免重复编译。</li><li><strong>Object.freeze</strong>：冻结大数据列表，避免 Vue 响应式劫持。</li></ul></li></ol><hr><h3 id="五、监控与分析" tabindex="-1">五、监控与分析 <a class="header-anchor" href="#五、监控与分析" aria-label="Permalink to &quot;五、监控与分析&quot;">​</a></h3><ol><li><strong>性能指标</strong><ul><li><strong>Core Web Vitals</strong>：优化 LCP（最大内容渲染时间）、CLS（累积布局偏移）、FID（首次输入延迟）。</li><li><strong>工具</strong>：Lighthouse 评分从 60 → 85，使用 <code>PerformanceObserver</code> 监控真实用户数据。</li></ul></li></ol><p>关于性能指标的补充：可参考<a href="https://web.dev/articles/vitals?hl=zh-cn#%E5%85%B6%E4%BB%96-web-%E6%8C%87%E6%A0%87%EF%BC%8C%E6%9C%89%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%E7%9A%84%E7%A0%94%E7%A9%B6%EF%BC%8C%E6%97%B6%E6%95%88%E6%80%A7%E4%B9%9F%E5%BE%88%E5%BC%BA" target="_blank" rel="noreferrer">https://web.dev/articles/vitals?hl=zh-cn#其他-web-指标，有非常详细的研究，时效性也很强</a> 一般关注这三个特性：加载速度、互动性和视觉稳定性 Largest Contentful Paint (LCP)：衡量加载性能。为了提供良好的用户体验，应在网页首次开始加载的 2.5 秒内完成 LCP。 Interaction to Next Paint (INP)：衡量互动性。为了提供良好的用户体验，网页的 INP 应不超过 200 毫秒。 Cumulative Layout Shift (CLS)：衡量视觉稳定性。为了提供良好的用户体验，网页的 CLS 应保持在 0.1 或更低。</p><p><img src="`+s+'" alt=""> FP（First Paint）是 Web 性能监测指标之一，指的是页面的首次渲染时间，即浏览器首次将任何内容渲染到屏幕上的时间点。FP 是用户感知页面加载速度的第一个关键指标，通常用来评估页面的加载速度和用户体验。 FCP：首次内容绘制，浏览器首次绘制DOM的时间，这是用户第一次看到的内容。最佳用户体验的FCP建议在2秒以内，如果超过4秒则表示页面首次内容绘制很慢。（哪些调整会影响该指标） 案例分析：<a href="https://juejin.cn/post/7208451786964598841" target="_blank" rel="noreferrer">https://juejin.cn/post/7208451786964598841</a></p><ol><li><strong>代码拆分分析</strong><ul><li><strong>工具</strong>：<code>Webpack Bundle Analyzer</code> 分析产物，合并重复依赖（如 lodash 按需引入）。</li></ul></li></ol><hr><p>这里补充一个点 开发过程中的性能优化</p><ol><li>构建优化，omp模块化构建优化的例子</li><li>框架升级</li></ol><h3 id="高频面试问题" tabindex="-1">高频面试问题 <a class="header-anchor" href="#高频面试问题" aria-label="Permalink to &quot;高频面试问题&quot;">​</a></h3><ol><li><p><strong>Q</strong>：如何从 6s 降到 2s 的首屏加载时间？</p><ul><li><strong>A</strong>：分析关键路径 → 压缩首屏资源 → 懒加载非关键组件 → CDN 加速 → 服务端渲染（SSR）。</li></ul></li><li><p><strong>Q</strong>：优化无限滚动列表卡顿？</p><ul><li><strong>A</strong>：虚拟列表 + 骨架屏占位 + 防抖加载数据。</li></ul></li><li><p><strong>Q</strong>：如何减少白屏时间？</p><ul><li><strong>A</strong>：SSR 服务端渲染 + 内联关键 CSS + 预加载字体。</li></ul></li></ol><hr>',25),n=[r];function a(p,c,h,d,g,u){return i(),t("div",{"data-pagefind-body":!0},n)}const f=e(o,[["render",a]]);export{E as __pageData,f as default};
