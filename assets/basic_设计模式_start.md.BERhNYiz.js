import{_ as o,o as r,c as i,I as s,w as t,a,j as e,a8 as n,D as p}from"./chunks/framework.Q0X2mdF-.js";const nl=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"basic/设计模式/start.md","filePath":"basic/设计模式/start.md","lastUpdated":null}'),c={name:"basic/设计模式/start.md"},h=n(`<h2 id="几个问题" tabindex="-1">几个问题 <a class="header-anchor" href="#几个问题" aria-label="Permalink to &quot;几个问题&quot;">​</a></h2><h3 id="动态类型语言与静态类型语言的区别" tabindex="-1">动态类型语言与静态类型语言的区别 <a class="header-anchor" href="#动态类型语言与静态类型语言的区别" aria-label="Permalink to &quot;动态类型语言与静态类型语言的区别&quot;">​</a></h3><h3 id="面向接口编程和面向实现编程的区别" tabindex="-1">面向接口编程和面向实现编程的区别 <a class="header-anchor" href="#面向接口编程和面向实现编程的区别" aria-label="Permalink to &quot;面向接口编程和面向实现编程的区别&quot;">​</a></h3><h3 id="多态含义-js需要多态吗" tabindex="-1">多态含义 js需要多态吗？ <a class="header-anchor" href="#多态含义-js需要多态吗" aria-label="Permalink to &quot;多态含义 js需要多态吗？&quot;">​</a></h3><blockquote><h3 id="而-javascript-的变量类型在运行期是可变的。一个-javascript-对象-既可以表示-duck-类型的" tabindex="-1">而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以表示 Duck 类型的 <a class="header-anchor" href="#而-javascript-的变量类型在运行期是可变的。一个-javascript-对象-既可以表示-duck-类型的" aria-label="Permalink to &quot;而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以表示 Duck 类型的&quot;">​</a></h3><p>对象，又可以表示 Chicken 类型的对象，这意味着 JavaScript 对象的多态性是与生俱来的。</p><p>这种与生俱来的多态性并不难解释。JavaScript 作为一门动态类型语言，它在编译时没有类型</p><p>检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。在 1.2.2 节的代码示例中，</p><p>我们既可以往 makeSound 函数里传递 duck 对象当作参数，也可以传递 chicken 对象当作参数。</p><p>由此可见，某一种动物能否发出叫声，只取决于它有没有 makeSound 方法，而不取决于它是</p><p>否是某种类型的对象，这里不存在任何程度上的“类型耦合”。这正是我们从上一节的鸭子类型</p><p>中领悟的道理。在 JavaScript 中，并不需要诸如向上转型之类的技术来取得多态的效果。</p></blockquote><h3 id="更广义的封装" tabindex="-1">更广义的封装 <a class="header-anchor" href="#更广义的封装" aria-label="Permalink to &quot;更广义的封装&quot;">​</a></h3><p>封装不仅仅是 隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。</p><h3 id="aop面向切面编程" tabindex="-1">AOP面向切面编程 <a class="header-anchor" href="#aop面向切面编程" aria-label="Permalink to &quot;AOP面向切面编程&quot;">​</a></h3><p>将与核心业务逻辑模块无关的功能抽离出来</p><p>在js中实现aop，指的是把一个函数动态植入到另一个函数中</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Function.prototype.before = function( beforefn ){</span></span>
<span class="line"><span> var __self = this; // 保存原函数的引用</span></span>
<span class="line"><span> return function(){ // 返回包含了原函数和新函数的&quot;代理&quot;函数</span></span>
<span class="line"><span> 	beforefn.apply( this, arguments ); // 执行新函数，修正 this</span></span>
<span class="line"><span> 	return __self.apply( this, arguments ); // 执行原函数</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Function.prototype.after = function( afterfn ){</span></span>
<span class="line"><span> var __self = this;</span></span>
<span class="line"><span> return function(){</span></span>
<span class="line"><span> 	var ret = __self.apply( this, arguments );</span></span>
<span class="line"><span> 	afterfn.apply( this, arguments );</span></span>
<span class="line"><span> 	return ret;</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var func = function(){</span></span>
<span class="line"><span> console.log( 2 );</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func = func.before(function(){</span></span>
<span class="line"><span> console.log( 1 );</span></span>
<span class="line"><span>}).after(function(){</span></span>
<span class="line"><span> console.log( 3 );</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func();</span></span></code></pre></div><p>使用aop的方式来给函数添加职责，是js中一种巧妙的装饰者模式实现。</p><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><p>学习设计模式前需要知道的几个点：</p><ol><li>将不变的部分与变化的部分隔开是每个设计模式的主题</li></ol><h3 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h3><h4 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>保证一个类只有一个实例，并提供一个访问它的全局访问点</p><h4 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h4><p>多次点击登录按钮，浮窗弹出，而不管登录按钮点击了多少次，浮窗应该只创建一次</p><p>这个在vue开发中也有所体现，比如一个悬浮提示</p><h4 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h4><p>实现的原则就是用一个变量来标志当前是否已经为某个类创建过对象。如果是，下一次访问该类的实例时，直接返回之前创建的对象。</p><p>比较好的实现方式：</p><p>代理方式</p><h4 id="js中的单例模式" tabindex="-1">js中的单例模式 <a class="header-anchor" href="#js中的单例模式" aria-label="Permalink to &quot;js中的单例模式&quot;">​</a></h4><p>js是无类语言，使用字面量方式创建一个对象，它就是唯一的，而且可以被全局访问。但是就全局变量而言，很容易造成命名空间污染。比如变量被覆盖等等</p><p>有两种方式可以避免：</p><ol><li>使用命名空间</li></ol><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var namespace1 = {</span></span>
<span class="line"><span> a: function(){</span></span>
<span class="line"><span> alert (1);</span></span>
<span class="line"><span> },</span></span>
<span class="line"><span> b: function(){</span></span>
<span class="line"><span> alert (2);</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>};</span></span></code></pre></div><ol start="2"><li>使用闭包封装私有变量</li></ol><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var user = (function(){</span></span>
<span class="line"><span> var __name = &#39;sven&#39;,</span></span>
<span class="line"><span> __age = 29;</span></span>
<span class="line"><span> return {</span></span>
<span class="line"><span> getUserInfo: function(){</span></span>
<span class="line"><span> return __name + &#39;-&#39; + __age;</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>})();</span></span></code></pre></div><h4 id="惰性单例" tabindex="-1">惰性单例 <a class="header-anchor" href="#惰性单例" aria-label="Permalink to &quot;惰性单例&quot;">​</a></h4><p>在需要使用到的时候才创建对象</p><h3 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h3><h4 id="定义-1" tabindex="-1">定义 <a class="header-anchor" href="#定义-1" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>使用一系列的算法，把它们一个个封装起来，并且相互可以替换</p><h4 id="实现-1" tabindex="-1">实现 <a class="header-anchor" href="#实现-1" aria-label="Permalink to &quot;实现&quot;">​</a></h4><p>一个基于策略模式的程序至少有两部分组成：</p><ol><li>一组策略类，封装具体的算法，并负责具体的计算过程</li><li>环境类context，接收客户的请求，之后将请求委托给某一个策略类</li></ol><p>因此context中要维护对某个策略对象的引用</p><h4 id="js中的实现" tabindex="-1">js中的实现 <a class="header-anchor" href="#js中的实现" aria-label="Permalink to &quot;js中的实现&quot;">​</a></h4><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var strategies = {</span></span>
<span class="line"><span> &quot;S&quot;: function( salary ){</span></span>
<span class="line"><span> return salary * 4;</span></span>
<span class="line"><span> },</span></span>
<span class="line"><span> &quot;A&quot;: function( salary ){</span></span>
<span class="line"><span> return salary * 3;</span></span>
<span class="line"><span> },</span></span>
<span class="line"><span> &quot;B&quot;: function( salary ){</span></span>
<span class="line"><span> return salary * 2;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var calculateBonus = function( level, salary ){</span></span>
<span class="line"><span> return strategies[ level ]( salary );</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>console.log( calculateBonus( &#39;S&#39;, 20000 ) ); // 输出：80000</span></span>
<span class="line"><span>console.log( calculateBonus( &#39;A&#39;, 10000 ) ); // 输出：30000</span></span></code></pre></div><p>这里体现了对象多态性， 。替换 Context 中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。</p><p>结合高阶函数的实现</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var S = function( salary ){</span></span>
<span class="line"><span> return salary * 4;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>var A = function( salary ){</span></span>
<span class="line"><span> return salary * 3;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>var B = function( salary ){</span></span>
<span class="line"><span> return salary * 2;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>var calculateBonus = function( func, salary ){</span></span>
<span class="line"><span> return func( salary );</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>calculateBonus( S, 10000 ); // 输出：40000</span></span></code></pre></div><blockquote><p>在函数作为一等对象的语言中，策略模式是隐形的，strategy就是值为函数的变量</p></blockquote><p>实际上在 JavaScript 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身</p><p>当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函</p><p>数发出“调用”的消息时，不同的函数会返回不同的执行结果。</p><p>因此可以说在js中，函数对象的多态性来的更加简单。</p><h4 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h4><p>优点：</p><p> 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</p><p> 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它</p><p>们易于切换，易于理解，易于扩展。</p><p> 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。</p><p> 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻</p><p>便的替代方案。</p><p>缺点：</p><p>对于每一个策略<code>strategy</code>都必须了解清楚，违背了最少知识原则。</p><h3 id="代理模式" tabindex="-1">代理模式 <a class="header-anchor" href="#代理模式" aria-label="Permalink to &quot;代理模式&quot;">​</a></h3><h4 id="定义-2" tabindex="-1">定义 <a class="header-anchor" href="#定义-2" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>为一个对象提供一个代用品或者占位符，以便控制对他的访问</p><h4 id="关键" tabindex="-1">关键 <a class="header-anchor" href="#关键" aria-label="Permalink to &quot;关键&quot;">​</a></h4><p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身</p><p>对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之</p><p>后，再把请求转交给本体对象</p><h4 id="保护代理与虚拟代理" tabindex="-1">保护代理与虚拟代理 <a class="header-anchor" href="#保护代理与虚拟代理" aria-label="Permalink to &quot;保护代理与虚拟代理&quot;">​</a></h4><ol><li>虚拟代理</li></ol><p>等到合适的情况下，代理再执行操作。</p><p>虚拟代理把一些开销很大的对象，延迟到 真正需要它的时候才去创建</p><ol start="2"><li>保护代理</li></ol><p>用于控制不同权限的对象对目标对象的访问，但在 JavaScript 并不容易实现保护代 理，因为我们无法判断谁访问了某个对象</p><h4 id="代理的意义" tabindex="-1">代理的意义 <a class="header-anchor" href="#代理的意义" aria-label="Permalink to &quot;代理的意义&quot;">​</a></h4><p>符合单一职责原则和开放封闭原则</p><h4 id="案例" tabindex="-1">案例 <a class="header-anchor" href="#案例" aria-label="Permalink to &quot;案例&quot;">​</a></h4><ol><li>虚拟代理合并请求</li><li>虚拟代理在惰性加载中的应用</li></ol><h4 id="缓存代理" tabindex="-1">缓存代理 <a class="header-anchor" href="#缓存代理" aria-label="Permalink to &quot;缓存代理&quot;">​</a></h4><p>缓存代理在平时的编程中应用的非常多，尤其是结合了高阶函数之后</p><p>比如重复的计算结果，重复的异步请求（前提是每次请求的结果是一致的）</p><h3 id="迭代器模式" tabindex="-1">迭代器模式 <a class="header-anchor" href="#迭代器模式" aria-label="Permalink to &quot;迭代器模式&quot;">​</a></h3>`,82),d=n('<h4 id="定义-3" tabindex="-1">定义 <a class="header-anchor" href="#定义-3" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象</p><p>的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即</p><p>使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p><h4 id="内部迭代器和外部迭代器" tabindex="-1">内部迭代器和外部迭代器 <a class="header-anchor" href="#内部迭代器和外部迭代器" aria-label="Permalink to &quot;内部迭代器和外部迭代器&quot;">​</a></h4><p>内部迭代器调用的时候非常方便，外界不用关心迭代器内部的实现，但是此时迭代规则也确定了，不能够更改。相对来说，外部迭代器必须显式地请求迭代下一个元素。他们俩的使用需要看具体场景。</p><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><h4 id="实例" tabindex="-1">实例 <a class="header-anchor" href="#实例" aria-label="Permalink to &quot;实例&quot;">​</a></h4><p>可以改造if else语句相关逻辑</p><p>以next-tick.js源码为例！promise-》mutation-》setImmediate</p><h3 id="发布订阅模式" tabindex="-1">发布订阅模式 <a class="header-anchor" href="#发布订阅模式" aria-label="Permalink to &quot;发布订阅模式&quot;">​</a></h3><h4 id="定义-4" tabindex="-1">定义 <a class="header-anchor" href="#定义-4" aria-label="Permalink to &quot;定义&quot;">​</a></h4>',12),u=e("h4",{id:"必须先订阅再发布吗",tabindex:"-1"},[a("必须先订阅再发布吗 "),e("a",{class:"header-anchor",href:"#必须先订阅再发布吗","aria-label":'Permalink to "必须先订阅再发布吗"'},"​")],-1),b=e("p",null,"不一定，因为受一些不确定的因素影响，比如异步消息返回的比较快，也就是已经发布了信息，但是订阅者还未来得及订阅，特别使用了一些模块化惰性加载的时候，",-1),_={id:"js实现发布订阅模式的便利性",tabindex:"-1"},g=e("a",{class:"header-anchor",href:"#js实现发布订阅模式的便利性","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">js实现发布订阅模式的便利性</font>"'},"​",-1),f={id:"发布订阅模式的缺点",tabindex:"-1"},y=e("a",{class:"header-anchor",href:"#发布订阅模式的缺点","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">发布订阅模式的缺点</font>"'},"​",-1),k={id:"创建订阅者本身要消耗一定的时间和内存-而",tabindex:"-1"},m=e("a",{class:"header-anchor",href:"#创建订阅者本身要消耗一定的时间和内存-而","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">创建订阅者本身要消耗一定的时间和内存，而 </font>"'},"​",-1),x=e("h3",{id:"命令模式",tabindex:"-1"},[a("命令模式 "),e("a",{class:"header-anchor",href:"#命令模式","aria-label":'Permalink to "命令模式"'},"​")],-1),P=e("h4",{id:"定义-5",tabindex:"-1"},[a("定义 "),e("a",{class:"header-anchor",href:"#定义-5","aria-label":'Permalink to "定义"'},"​")],-1),q=e("h4",{id:"js中的命令模式",tabindex:"-1"},[a("js中的命令模式 "),e("a",{class:"header-anchor",href:"#js中的命令模式","aria-label":'Permalink to "js中的命令模式"'},"​")],-1),E=e("p",null,"命令模式的由来，其实是回调函数的一个面向对象的替代品",-1),v=e("p",null,"js作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到js中，因为函数作为一等公民（对象），本身就可以被四处传递，可作为参数传入，可返回。",-1),F=e("p",null,"因此可以使用闭包的方式来实现",-1),j=e("h4",{id:"可定义的行为",tabindex:"-1"},[a("可定义的行为 "),e("a",{class:"header-anchor",href:"#可定义的行为","aria-label":'Permalink to "可定义的行为"'},"​")],-1),C=n('<p>执行（execute）/撤销（）</p><p>还可用于ctrl+Z和悔棋的功能，</p><h4 id="撤销和重做" tabindex="-1">撤销和重做 <a class="header-anchor" href="#撤销和重做" aria-label="Permalink to &quot;撤销和重做&quot;">​</a></h4><p>对于不容易直接逆转的操作，像让小球移动到上一个位置这样的行为（撤销），可以记录下当前已经执行过的所有命令，然后重播，从头再执行一遍这些命令。</p><h4 id="实践" tabindex="-1">实践 <a class="header-anchor" href="#实践" aria-label="Permalink to &quot;实践&quot;">​</a></h4><p>实现一个案例，结合策略模式，发布订阅模式，命令模式</p><ol><li>策略模式：一个小球以不同的方式进行移动； 5.4</li><li>命令模式：手动给一个指令，前进或撤销或重置来操作小球，如果点击的过快，也应该执行完上一次再继续执行下一次，而不是直接重新执行，也就是实现一个命令队列；先通过回调来完成下一次出队执行9.6</li><li>发布订阅模式：上一次动画结束之后，notify，通知队列，队列的 update 就是出队第一个元素，且这个元素执行完成后，依旧是通知订阅者。8.4</li></ol>',7),A=e("h4",{id:"宏命令",tabindex:"-1"},[a("宏命令 "),e("a",{class:"header-anchor",href:"#宏命令","aria-label":'Permalink to "宏命令"'},"​")],-1),S={id:"智能模式与傻瓜命令",tabindex:"-1"},T=e("a",{class:"header-anchor",href:"#智能模式与傻瓜命令","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">智能模式与傻瓜命令</font>"'},"​",-1),D=e("h3",{id:"组合模式",tabindex:"-1"},[a("组合模式 "),e("a",{class:"header-anchor",href:"#组合模式","aria-label":'Permalink to "组合模式"'},"​")],-1),B=e("h4",{id:"定义-6",tabindex:"-1"},[a("定义 "),e("a",{class:"header-anchor",href:"#定义-6","aria-label":'Permalink to "定义"'},"​")],-1),O=n('<p><strong>用途</strong></p><p>利用对象多态性统一对待组合对象和单个对象，可以忽略组合对象个单个对象的不同，只要都能执行命令就行</p><h4 id="更强大的宏命令" tabindex="-1">更强大的宏命令 <a class="header-anchor" href="#更强大的宏命令" aria-label="Permalink to &quot;更强大的宏命令&quot;">​</a></h4><p>基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，再进行深度优先便可以遍历整棵树，书上的例子又体现了我们可以忽视对象和多个对象的区别，只要保证它们都有<code>execute</code>方法。</p><p>这有点像函数式编程中函数组合<code>compose</code>的概念</p><h4 id="js中的组合模式" tabindex="-1">js中的组合模式 <a class="header-anchor" href="#js中的组合模式" aria-label="Permalink to &quot;js中的组合模式&quot;">​</a></h4>',6),I={id:"需要注意的地方",tabindex:"-1"},V=e("a",{class:"header-anchor",href:"#需要注意的地方","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">需要注意的地方</font>"'},"​",-1),J=e("ul",null,[e("li",null,"组合对象与叶对象具有相同的接口"),e("li",null,"对一组叶对象的操作必须具有一致性")],-1),N={start:"3"},R={id:"在组合模式中使用职责链",tabindex:"-1"},w=e("a",{class:"header-anchor",href:"#在组合模式中使用职责链","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">在组合模式中使用职责链</font>"'},"​",-1),U=e("ul",null,[e("li",null,"[ ] 一个删除文件夹的例子，结合职责链来实现！")],-1),$=e("h4",{id:"组合模式的优缺点",tabindex:"-1"},[a("组合模式的优缺点 "),e("a",{class:"header-anchor",href:"#组合模式的优缺点","aria-label":'Permalink to "组合模式的优缺点"'},"​")],-1),M=e("ol",null,[e("li",null,"优点")],-1),L={start:"2"},Q={id:"模板方法模式",tabindex:"-1"},W=e("a",{class:"header-anchor",href:"#模板方法模式","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">模板方法模式</font>"'},"​",-1),Z={id:"定义-7",tabindex:"-1"},z=e("a",{class:"header-anchor",href:"#定义-7","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">定义</font>"'},"​",-1),G={id:"组成",tabindex:"-1"},H=e("a",{class:"header-anchor",href:"#组成","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">组成</font>"'},"​",-1),K={id:"抽象类",tabindex:"-1"},X=e("a",{class:"header-anchor",href:"#抽象类","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">抽象类</font>"'},"​",-1),Y=e("p",null,"模板方法模式严重依赖抽象类，js在语言层面上并没有提供对抽象类的支持。",-1),aa={id:"使用场景",tabindex:"-1"},la=e("a",{class:"header-anchor",href:"#使用场景","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">使用场景</font>"'},"​",-1),sa={id:"钩子方法",tabindex:"-1"},ea=e("a",{class:"header-anchor",href:"#钩子方法","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">钩子方法</font>"'},"​",-1),ta={id:"好莱坞原则",tabindex:"-1"},na=e("a",{class:"header-anchor",href:"#好莱坞原则","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">好莱坞原则</font>"'},"​",-1),oa=e("p",null,"这三个都符合好莱坞原则",-1),ra=e("h4",{id:"js中真的需要继承吗",tabindex:"-1"},[a("js中真的需要继承吗 "),e("a",{class:"header-anchor",href:"#js中真的需要继承吗","aria-label":'Permalink to "js中真的需要继承吗"'},"​")],-1),ia=e("h3",{id:"亨元模式",tabindex:"-1"},[a("亨元模式 "),e("a",{class:"header-anchor",href:"#亨元模式","aria-label":'Permalink to "亨元模式"'},"​")],-1),pa=e("h4",{id:"定义-8",tabindex:"-1"},[a("定义 "),e("a",{class:"header-anchor",href:"#定义-8","aria-label":'Permalink to "定义"'},"​")],-1),ca={id:"内部状态和外部状态",tabindex:"-1"},ha=e("a",{class:"header-anchor",href:"#内部状态和外部状态","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">内部状态和外部状态</font>"'},"​",-1),da=e("h4",{id:"通用结构",tabindex:"-1"},[a("通用结构 "),e("a",{class:"header-anchor",href:"#通用结构","aria-label":'Permalink to "通用结构"'},"​")],-1),ua=e("ol",null,[e("li",null,"只有当某种共享对象被真正需要时，它才从工厂中被创建出来"),e("li",null,"当外部状态非常复杂时，他们与共享对象的联系会变得十分困难，因此将使用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子与共享对象联系起来。")],-1),ba=e("h4",{id:"使用场景-1",tabindex:"-1"},[a("使用场景 "),e("a",{class:"header-anchor",href:"#使用场景-1","aria-label":'Permalink to "使用场景"'},"​")],-1),_a={id:"没有内部状态的亨元和没有外部状态的亨元",tabindex:"-1"},ga=e("a",{class:"header-anchor",href:"#没有内部状态的亨元和没有外部状态的亨元","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">没有内部状态的亨元和没有外部状态的亨元</font>"'},"​",-1),fa=n(`<div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var Upload = function(){};</span></span>
<span class="line"><span>var UploadFactory = (function(){</span></span>
<span class="line"><span>var uploadObj;</span></span>
<span class="line"><span> return {</span></span>
<span class="line"><span> create: function(){</span></span>
<span class="line"><span> if ( uploadObj ){</span></span>
<span class="line"><span> return uploadObj;</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> return uploadObj = new Upload();</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>})();</span></span></code></pre></div>`,1),ya={id:"对象池技术",tabindex:"-1"},ka=e("a",{class:"header-anchor",href:"#对象池技术","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">对象池技术</font>"'},"​",-1),ma={id:"职责链模式",tabindex:"-1"},xa=e("a",{class:"header-anchor",href:"#职责链模式","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">职责链模式</font>"'},"​",-1),Pa={id:"定义-9",tabindex:"-1"},qa=e("a",{class:"header-anchor",href:"#定义-9","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">定义</font>"'},"​",-1),Ea={id:"灵活可拆分的职责链节点",tabindex:"-1"},va=e("a",{class:"header-anchor",href:"#灵活可拆分的职责链节点","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">灵活可拆分的职责链节点</font>"'},"​",-1),Fa={id:"异步的职责链",tabindex:"-1"},ja=e("a",{class:"header-anchor",href:"#异步的职责链","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">异步的职责链</font>"'},"​",-1),Ca=e("h4",{id:"职责链模式的优缺点",tabindex:"-1"},[a("职责链模式的优缺点 "),e("a",{class:"header-anchor",href:"#职责链模式的优缺点","aria-label":'Permalink to "职责链模式的优缺点"'},"​")],-1),Aa=e("p",null,"优点：",-1),Sa=e("li",null,"解耦了请求发送者和n个接受者之间的复杂关系",-1),Ta={start:"3"},Da={id:"用aop实现职责链",tabindex:"-1"},Ba=e("a",{class:"header-anchor",href:"#用aop实现职责链","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">用Aop实现职责链</font>"'},"​",-1),Oa=e("p",null,"结合AOP，叠加了函数的作用域，虽然把函数叠加在一起，但如果链条太长的话，可能会对性能造成影响。",-1),Ia=e("h4",{id:"应用-1",tabindex:"-1"},[a("应用 "),e("a",{class:"header-anchor",href:"#应用-1","aria-label":'Permalink to "应用"'},"​")],-1),Va={id:"中介者模式",tabindex:"-1"},Ja=e("a",{class:"header-anchor",href:"#中介者模式","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">中介者模式</font>"'},"​",-1),Na=e("h4",{id:"定义-10",tabindex:"-1"},[a("定义 "),e("a",{class:"header-anchor",href:"#定义-10","aria-label":'Permalink to "定义"'},"​")],-1),Ra={id:"案例-1",tabindex:"-1"},wa=e("a",{class:"header-anchor",href:"#案例-1","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">案例</font>"'},"​",-1),Ua={id:"最少知识原则",tabindex:"-1"},$a=e("a",{class:"header-anchor",href:"#最少知识原则","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">最少知识原则</font>"'},"​",-1),Ma={id:"缺点",tabindex:"-1"},La=e("a",{class:"header-anchor",href:"#缺点","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">缺点</font>"'},"​",-1),Qa={id:"装饰者模式",tabindex:"-1"},Wa=e("a",{class:"header-anchor",href:"#装饰者模式","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">装饰者模式</font>"'},"​",-1),Za=n(`<h4 id="定义-11" tabindex="-1">定义 <a class="header-anchor" href="#定义-11" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象</p><p>并且不改变对象自身，只是在程序运行期间给对象动态地添加职责。</p><h4 id="装饰函数" tabindex="-1">装饰函数 <a class="header-anchor" href="#装饰函数" aria-label="Permalink to &quot;装饰函数&quot;">​</a></h4><p>在不改变函数源代码的情况下，给函数增加功能。普通的用一个变量来保存函数就可以实现，但是要注意this绑定丢失的问题。</p><h4 id="aop结合装饰者模式" tabindex="-1">AOP结合装饰者模式 <a class="header-anchor" href="#aop结合装饰者模式" aria-label="Permalink to &quot;AOP结合装饰者模式&quot;">​</a></h4><ol><li>降低耦合性，两个层面的功能使用AOP进行分离</li><li>aop动态改变函数参数，<strong>一个例子就是在axios请求前给请求头加上token参数</strong></li><li><strong>插件式的表单验证，使用before分离了表单验证和表单提交</strong></li></ol><hr><p><strong>tip：</strong></p><p><strong>这么做的缺点：这种装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会有一些影响。</strong></p><p>装饰者模式和代理模式</p><p>通过例子思考两者的区别</p><h3 id="状态模式" tabindex="-1">状态模式 <a class="header-anchor" href="#状态模式" aria-label="Permalink to &quot;状态模式&quot;">​</a></h3><h4 id="定义-12" tabindex="-1">定义 <a class="header-anchor" href="#定义-12" aria-label="Permalink to &quot;定义&quot;">​</a></h4><p>维护内部状态，将内部状态与对应的行为局部化</p><h4 id="应用-2" tabindex="-1">应用 <a class="header-anchor" href="#应用-2" aria-label="Permalink to &quot;应用&quot;">​</a></h4><p>状态模式对于实际中的应用非常重要，以一个电灯的案例我联想到项目中的排序按钮，先平序，然后增序，最后降序。原来的写法明显违背了开放封闭原则，换做是其他的案例，则根本不知道有多少个状态，当初我的解决办法是加了一个取模，使用状态模式是否更好地解决这个问题呢?是可以的，</p><p>先看一下element-plus/table中的处理</p><p><a href="https://github.com/element-plus/element-plus/blob/67037470324a12ec152d219542281d1120941295/packages/components/table/src/table-header/event-helper.ts#L142" target="_blank" rel="noreferrer">https://github.com/element-plus/element-plus/blob/67037470324a12ec152d219542281d1120941295/packages/components/table/src/table-header/event-helper.ts#L142</a></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toggleOrder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">order</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sortOrders</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortOrders[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortOrders.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortOrders[index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortOrders.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sortOrders</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ascending&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;descending&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[]</span></span></code></pre></div><p>这种处理方式比取模更好，少了取模的计算。</p><h4 id="关键点" tabindex="-1">关键点 <a class="header-anchor" href="#关键点" aria-label="Permalink to &quot;关键点&quot;">​</a></h4><p>把事物的每种状态都封装成单独的类，跟这种状态有关的行为都被封装在这个类的内部，同时还可以把状态的切换规则事先分布在状态类中。好处就是每一种状态和它对应的行为的关系局部化，这些行为被分散和封装在各自对应的状态类中。</p><h4 id="通用的结构" tabindex="-1">通用的结构 <a class="header-anchor" href="#通用的结构" aria-label="Permalink to &quot;通用的结构&quot;">​</a></h4><p>有一个context状态机，维护着所有状态对象</p><h4 id="优缺点-1" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点-1" aria-label="Permalink to &quot;优缺点&quot;">​</a></h4><p>优点：1. 定义了状态与行为之间的关系，并封装在一个类里</p><ol start="2"><li>避免了context无限膨胀，状态切换的逻辑分布在状态类中</li></ol><p>缺点：会在系统中定义许多的类</p><h4 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h4><p>例子中是为每个context对象都创建了一组state对象，实际上这些state对象之间是可以共享的，使用亨元模式来改写</p><h4 id="策略模式和状态模式的对比" tabindex="-1">策略模式和状态模式的对比 <a class="header-anchor" href="#策略模式和状态模式的对比" aria-label="Permalink to &quot;策略模式和状态模式的对比&quot;">​</a></h4>`,32),za={id:"js中的状态机",tabindex:"-1"},Ga=e("a",{class:"header-anchor",href:"#js中的状态机","aria-label":'Permalink to "<font style="color:rgb(0,0,0);">js中的状态机</font>"'},"​",-1),Ha=n("<p>使用委托技术，并不需要事先让一个对象持有另一个对象，在js中可以使用call方法直接把请求委托给某个字面量对象来执行。</p><p>适配器模式</p><p>定义</p><p>解决两个软件实体之间的接口不兼容的问题，别名是包装器</p><p>关键点总结</p><ol><li>是一种亡羊补牢的做法，因为在设计之初并不知道要适配未来的事物</li><li>来自于第三方的api，我们不应该去直接更改他</li></ol><p>和其他设计模式的区别</p><ol><li>和装饰者模式，代理模式，外观模式的区别</li></ol>",8);function Ka(Xa,Ya,al,ll,sl,el){const l=p("font");return r(),i("div",{"data-pagefind-body":!0},[h,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("的绝大部分语言都内置了迭代器。")]),_:1}),d,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("—")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("态发生改变时，所有依赖于它的对象都将得到通知。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("p",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("疑问点")]),_:1})])]),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布订阅模式和观察者模式有区别吗？")]),_:1})])])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("比较认同的解释是：")]),_:1}),s(l,{style:{color:"rgb(81, 87, 103)"}},{default:t(()=>[a("我的理解发布订阅模式和观察者模式本质是一样的，只不过名字不一样。这就好比你小名叫臭臭，身份证叫香香。二者都是为了解决一类共同的问题，都是为了收集注册的回调方法，到该触发的时机去执行。并不是多了个任务中心就不一样了，无非多几行代码的事，把代码再优化优化。就好比webpack执行loader所用的compose 函数，所以它仅仅是一种”代码实现方式”,也可被称为一种模式，")]),_:1}),a("**"),s(l,{style:{color:"rgb(81, 87, 103)"}},{default:t(()=>[a("因为模式这个东西本身是不存在编程语言中的，通俗地讲，设计模式可以理解为是为了解决具体的需求而出现的一种通用逻辑或者方案。")]),_:1}),a("**"),s(l,{style:{color:"rgb(81, 87, 103)"}},{default:t(()=>[a("举个例子:因为有疫情，怕接触感染。但我们需要找工作，公司也需要招员工，所以我们出现了线上面试应对这样的需求，而且它适合绝大部分求职者和公司。")]),_:1}),s(l,{style:{color:"rgb(81, 87, 103)"}},{default:t(()=>[a("所以我们可以把它理解为跟需求相匹配的一种解决问题的方式。二者完全可以认为是解决同一类型问题的方案，本质上没有任何区别！")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("所以还是按照书本中所说，发布订阅模式又叫观察者模式，只是我们要看不同的场景进行改动。")]),_:1}),u,b,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被 存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("QQ ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("的未读消息只会被重 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("新阅读一次，所以刚才的操作我们只能进行一次。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",_,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("js实现发布订阅模式的便利性")]),_:1}),a(),g]),e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("在js中，可以使用注册回调的形式")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("选择推模型（事件发生时，发布者一次性将所有更改的状态和数据都推送给订阅者），使用 Function.prototype.apply 方法把所有参数都推送给订阅者")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",f,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布订阅模式的缺点")]),_:1}),a(),y]),e("blockquote",null,[e("h4",k,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("创建订阅者本身要消耗一定的时间和内存，而 ")]),_:1}),a(),m]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("—")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("起的时候，要跟踪一个 bug 不是件轻松的事情。")]),_:1})]),x,P,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。")]),_:1}),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("设计模式的主题总是把不变的事物和变化的事物分离开来")]),_:1})])])]),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("而且js可以用高阶函数非常方便地实现命令模式，在js中是一种隐形模式")]),_:1})])])]),q,E,v,F,j,e("p",null,[a("命令模式的作用不仅是封装运算块，"),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("而且可以很方便地给命令对象增加撤销操作。就像订餐 时客人可以通过电话来取消订单一样。")]),_:1})]),C,s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("需要更改的地方，将当前的目标位置更改为步长")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),A,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。它是命令模式与组合模式的结合。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",S,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("智能模式与傻瓜命令")]),_:1}),a(),T]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("一般来说，命令模式都会在 command 对象中保存一个接收者来负责真正执行客户的请求，这种情况下命令对象是“傻瓜式”的，它只负责把客户的请求转交给接收者来执行，这种模式的好处是请求发起者和请求接收者之间尽可能地得到了解耦。 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("但是我们也可以定义一些更“聪明”的命令对象，“聪明”的命令对象可以直接实现请求， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("这样一来就不再需要接收者的存在，这种“聪明”的命令对象也叫作智能命令。没有接收者的智 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("能命令，退化到和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们意图 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("的不同。")]),_:1}),a("**"),s(l,{style:{color:"#597EF7"}},{default:t(()=>[a("策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标 ")]),_:1}),a("**"),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}},{default:t(()=>[a("的不同手段，它们的内部实现是针对“算法”而言的。而智能命令模式指向的问题域更广，")]),_:1}),a("****"),s(l,{style:{color:"#597EF7"}},{default:t(()=>[a("command ")]),_:1})])]),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}},{default:t(()=>[a("对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。")]),_:1})])]),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}})])]),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}})])]),e("p",null,[e("strong",null,[s(l,{style:{color:"#597EF7"}})])]),D,B,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("小的“孙对象”构成的。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),O,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("JavaScript 中实现组合模式的难点在于要保证组合对象和叶对象对象拥有同样的方法，这通常需要用鸭子类型的思想对它们进行 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("接口检查。 在 JavaScript 中实现组合模式，看起来缺乏一些严谨性，我们的代码算不上安全，但能更快 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("速和自由地开发，这既是 JavaScript 的缺点，也是它的优点。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",I,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("需要注意的地方")]),_:1}),a(),V]),e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("组合模式不是父子关系")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对叶对象操作的一致性")]),_:1})])]),J,e("ol",N,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("当对象之间的关系并不是严格意义上的层次结构，不适用于使用组合模式")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("可以使用职责链模式提高组合模式性能？")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",R,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("在组合模式中使用职责链")]),_:1}),a(),w]),U,$,M,e("ul",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("表示对象的部分整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分整 ")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("式中增加和删除树的节点非常方便，并且符合开放")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("封闭原则。 ")]),_:1}),e("ul",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别， ")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("不用写一堆 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("if")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("、")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("else ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("这是组合模式最重要的能力。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("ol",L,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("缺点")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("如果系统中的每个对象看起来都和其他对象差不多，区别只有在运行的时候才能体现出来，那么就不适合用组合模式了。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h3",Q,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法模式")]),_:1}),a(),W]),e("h4",Z,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("定义")]),_:1}),a(),z]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("是一种基于继承的设计模式，")]),_:1}),a(),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语 言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改 动抽象父类以及其他子类，这也是符合开放封闭原则的。 但在 JavaScript 中，我们很多时候都不需要依样画瓢地去实现一个模版方法模式，高阶函数是更好的选择。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",G,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("组成")]),_:1}),a(),H]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("在一个例子中找到哪个是模板方法，")]),_:1}),a("**"),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法中会封装子类的算法框架")]),_:1}),a("**"),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",K,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("抽象类")]),_:1}),a(),X]),Y,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，当子类继承了这个抽象类时，必须重写父类的抽象方法。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("js中实现抽象类的缺点：无法保证子类会重写抽象类的方法，解决方案是可以使用鸭子类型判断或者在抽象方法中抛出异常")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",aa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("使用场景")]),_:1}),a(),la]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("在 Web 开发中也能找到很多模板方法模式的适用场景，比如我们在构建一系列的 UI 组件， 这些组件的构建过程一般如下所示： ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("(1) ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("初始化一个 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("div ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("容器； ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("(2) ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("通过 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("ajax ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("请求拉取相应的数据； ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("(3) ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("把数据渲染到 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("div ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("容器里面，完成组件的构造； ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("(4) 通知用户组件渲染完毕。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",sa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("钩子方法")]),_:1}),a(),ea]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("如果子类有异样的行为时，该如何区分呢？")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("钩子方法（hook）可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父 类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自 行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",ta,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("好莱坞原则")]),_:1}),a(),na]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("别调用我们，我们会调用你")]),_:1}),e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("模板方法模式")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发布订阅模式")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("回调函数")]),_:1})])]),oa,ra,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("JavaScript 语言实际上没有提供真正的类式继承，继承是通过对象与对 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("象之间的委托来实现的。而模板方法模式是严重依赖于类的概念，所以这里使用js强行实现的模板方法模式并不正宗。")]),_:1}),ia,pa,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("从后面的例子可以看出，有多少中内部状态的组合，系统中便最多存在多少个共享对象。")]),_:1})]),a("__** **")])]),e("p",null,[e("em",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。")]),_:1})])])]),s(l,{style:{color:"rgb(0,0,0)"}}),e("p",null,[e("strong",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("它是为了解决性能问题而生的问题")]),_:1})])]),e("h4",ca,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("内部状态和外部状态")]),_:1}),a(),ha]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("这是亨元模式的构成")]),_:1}),e("ul",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("内部状态存储于对象内部。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("内部状态可以被一些对象共享。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("内部状态独立于具体的场景，通常不会改变。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),da,ua,ba,e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("一个程序中使用了大量的相似对象。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("由于使用了大量对象，造成很大的内存开销。 ")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对象的大多数状态")]),_:1}),a("**"),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("都可以变为外部状态。 ")]),_:1}),a("**")]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("文件上传就是一个很适合的例子")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",_a,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("没有内部状态的亨元和没有外部状态的亨元")]),_:1}),a(),ga]),fa,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("生产共享对象的工厂实际上变成了一个单例工厂。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",ya,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对象池技术")]),_:1}),a(),ka]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对象池维 护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如 果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入池子等待被下次获取。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("很多空间和时间都消耗在了 DOM 节点上，如何避免频繁地创建和删除 DOM 节点就成了一个有意义的话题。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("对象池与亨元模式类似，但它并没有主动分离内部状态和外部状态的过程。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h3",ma,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("职责链模式")]),_:1}),a(),xa]),e("h4",Pa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("定义")]),_:1}),a(),qa]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Ea,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("灵活可拆分的职责链节点")]),_:1}),a(),va]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("让链中的各个节点可以灵活拆分和重组")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Fa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("异步的职责链")]),_:1}),a(),ja]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("使用场景是：节点函数中发起一个 ajax异步请求，异步请求返回的结果才能决定是否继续在职责链中 passRequest")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),Ca,Aa,e("ol",null,[Sa,e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("链中的节点对象可以灵活地拆分重组。增加或者删除一个节 ")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("点，或者改变节点在链中的位置都是轻而易举的事情。")]),_:1}),e("ol",Ta,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("可以手动指定起始节点")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("缺点：")]),_:1}),e("ol",null,[e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("不能保证某个请求一定会被链中的节点处理。当请求得不到答复时，就会径直从链尾离开，或者抛 出一个错误异常。在这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离 开链尾的请求。")]),_:1})]),e("li",null,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分 节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避 免过长的职责链带来的性能损耗。")]),_:1})])]),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Da,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("用Aop实现职责链")]),_:1}),a(),Ba]),Oa,Ia,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("无论是作用域链、原型链，还是 DOM 节点中的事件冒泡，我们都能从中找到职责链模式的 影子。职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("效率。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h3",Va,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("中介者模式")]),_:1}),a(),Ja]),Na,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知 中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。使网状的多对多关系变成相对简单的一对多关系。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Ra,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("案例")]),_:1}),a(),wa]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("当节点对象都是耦合在一块时，一个节点的修改会造成多个节点的修改。改变或者增加任何一个节点对象，都要通知到与其相关的对象。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Ua,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("最少知识原则")]),_:1}),a(),$a]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("中介者模式符合最少知识原则，是指一个对象应 该尽可能少地了解另外的对象（类似不和陌生人说话）。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他的对象。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",Ma,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("缺点")]),_:1}),a(),La]),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("系统中要新增一个中介者对象，转移到中介者对象的复杂性")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h3",Qa,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("装饰者模式")]),_:1}),a(),Wa]),Za,s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("求委托给这些类来执行。 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("它们之间的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系， ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情 ")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。")]),_:1}),s(l,{style:{color:"rgb(0,0,0)"}}),s(l,{style:{color:"rgb(0,0,0)"}}),e("h4",za,[s(l,{style:{color:"rgb(0,0,0)"}},{default:t(()=>[a("js中的状态机")]),_:1}),a(),Ga]),Ha])}const ol=o(c,[["render",Ka]]);export{nl as __pageData,ol as default};
