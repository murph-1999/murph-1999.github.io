import{_ as s,o as n,c as a,a8 as e}from"./chunks/framework.Q0X2mdF-.js";const b=JSON.parse('{"title":"构造函数","description":"","frontmatter":{},"headers":[],"relativePath":"basic/js/原型.md","filePath":"basic/js/原型.md","lastUpdated":null}'),p={name:"basic/js/原型.md"},o=e(`<p>在掌握原型之前，请读者务必先掌握JS中的数据类型。</p><h1 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h1><p>一些读者可能对于面向类的语言有一定了解，导致混淆一些概念，但是JS中并没有类的固有概念，只是有<strong>类似的语法</strong>，如<code>new</code>和<code>instanceof</code>，以及在后来的es6中新增了类一些元素，如<code>class关键字</code>。所以暂时专注于了解JS中的对象机制。先来看看如何创建出一个对象吧！</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Person(){</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var person = new Person()</span></span></code></pre></div><p>首先要说明一点，Person 本身不是构造函数，它就是一个普通的函数，但是当使用new调用它，这个函数调用就变成了一个构造函数调用，构造出一个对象。只是不同于像Array，Object这样的原生构造函数，Person是我们自定义的构造函数。</p><h1 id="原型的由来" tabindex="-1">原型的由来 <a class="header-anchor" href="#原型的由来" aria-label="Permalink to &quot;原型的由来&quot;">​</a></h1><p>使用 new 调用了 Person 函数，构造出一个对象 person。但是使用构造函数来创建对象有一个弊端：每个方法都会在每个实例上重新创建一遍。对于这样的创建方式，不同实例上的同名函数是不相等的，getInfo在这里是两个Function实例。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Person(name, age){</span></span>
<span class="line"><span>    this.name = name</span></span>
<span class="line"><span>    this.age = age</span></span>
<span class="line"><span>    this.getInfo = function(){</span></span>
<span class="line"><span>        alert(this.name + this.age)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var person1 = new Person(&#39;Alice&#39;,23)</span></span>
<span class="line"><span>var person2 = new Person(&#39;Bob&#39;,25)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(person1.getInfo === person2.getInfo)  //false</span></span></code></pre></div><p>虽说要想解决这个问题，只要把函数定义挂载到全局作用域中就可以，但是如果对象需要多个方法呢？因此原型模式应运而来。</p><h1 id="prototype" tabindex="-1">prototype <a class="header-anchor" href="#prototype" aria-label="Permalink to &quot;prototype&quot;">​</a></h1><p>在JS中，创建的<strong>每个函数</strong>（注意：不是所有数据类型都拥有原型属性，只有函数对象拥有）都有一个 <code>prototype </code>属性。它是通过调用构造函数而创建的那个对象实例的原型对象，<strong>目的是让所有对象实例共享它包含的属性和方法</strong>。有点绕是不是？没事，先记住它的作用是什么，如你所见，我们给 <code>Person.prototype</code> 添加了同样的属性和方法，它确实解决了构造函数模式创建对象的问题：person1 和person2 访问的都是同一组属性和同一个getInfo函数。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Person(){}</span></span>
<span class="line"><span>Person.prototype.name = &#39;Bob&#39;</span></span>
<span class="line"><span>Person.prototype.age = 24</span></span>
<span class="line"><span>Person.prototype.getInfo=function(){</span></span>
<span class="line"><span>    alert(this.name + this.age)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var person1 = new Person()</span></span>
<span class="line"><span>var person2 = new Person()</span></span>
<span class="line"><span>alert(person1.getInfo === person2.getInfo) //true</span></span></code></pre></div><p>注意：有的人可能觉得 prototype 还是有点抽象，其实它就是一个对象，不过有普通对象和函数对象之分。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> console.log(typeof Person.prototype) //    Object</span></span>
<span class="line"><span> console.log(typeof Function.prototype) //   Function</span></span></code></pre></div><h1 id="原型链" tabindex="-1">原型链 <a class="header-anchor" href="#原型链" aria-label="Permalink to &quot;原型链&quot;">​</a></h1><p>person 是如何关联 Person.prototype 的呢？原来当调用一个构造函数创建一个新实例后，这个实例的内部包含一个指针指向构造函数的原型对象。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>person.__proto__ == Person.prototype //对象实例person指向构造函数Person的原型对象</span></span></code></pre></div><p>可以用<code>isPrototypeof()</code>来确定是否存在这样的关系。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Person.prototype.isPrototypeof(person) //true</span></span></code></pre></div><p>和prototype属性一样，只有函数对象拥有__proto__属性吗？没道理吧，以原生构造函数Object为例，</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var obj = {}</span></span>
<span class="line"><span>obj.__proto__=== Object.prototype // true</span></span></code></pre></div><p>所以一般的普通对象也有。并且表面上看基本类型也有这个属性。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cbd22880ab847e09171559adf63c4ee~tplv-k3u1fbpfcp-watermark.image?" alt="5F96E6E5-1057-45DA-B3C0-D3225A51A3CE.png"></p><p>这是因为当我们访问基本类型的属性的时候，会临时创建一个基本包装类型对象，可以像对象一样操作基本类型，执行完成之后立即销毁。正是因为<code>Number, String, Boolean</code>具有这种特殊的特性，所以它们又被称为基本包装类型。或许这也是大家认为”js中万物皆是对象“的原因吧，虽然从数据类型上来看并不是这样。</p><p>言归正传，<strong>proto</strong> 可以实现：如果在对象上没有找到需要的属性或者方法引用，会继续在原型链上进行查找。这个链接存在与实例与构造函数的原型对象之间，因此是__proto__实现了原型链机制。原型链的尽头是<code>Object.prototype</code>。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Object.prototype.__proto__ === null</span></span></code></pre></div><h1 id="constructor" tabindex="-1">constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;constructor&quot;">​</a></h1><p>原型对象会默认拥有一个 <code>constructor</code> 属性，并且指向这个构造函数。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Person.prototype.constructor == Person //true</span></span></code></pre></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7fcaf851e204e9f8ade425d6c1bc120~tplv-k3u1fbpfcp-watermark.image?" alt="7816790E-8405-41B5-8669-3CE0E5C1E3F7.png"> 但是 person 好像也有一个<code>constructor</code>属性。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>person.constructor == Person  //true</span></span></code></pre></div><p>字面意思好像是 person 由 Person 构造，但实际上 person.constructor 只是通过默认的<code>__proto__</code>属性与 Person 关联了起来，试着改变一下 Person.prototype，看看发生了什么吧。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Person() { /* .. */ }</span></span>
<span class="line"><span>Person.prototype = { /* .. */ }; // 创建一个新原型对象</span></span>
<span class="line"><span>var person = new Person();</span></span>
<span class="line"><span>person.constructor === Person; //false</span></span>
<span class="line"><span>person.construtor === Object //true</span></span></code></pre></div><p>其实 person 并没有 constructor 这个属性，但是它会寻找原型链上的 Person.prototype 是否有这个属性，它也没有，因为被修改了，于是找到了原型链的顶端，Object.prototype，这个对象有 .construtor 属性，指向内置的 Object() 函数。</p><h1 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h1><ol><li><p>JS中的构造函数就是所有带 new 的函数调用；</p></li><li><p>原型对象本质上也是通过构造函数创建出的实例，只是有点特殊，因为其他的实例会继承 prototype 的所有属性和方法，实例通过设置自己的__proto__指向构造函数的prototype来实现这种继承；</p></li><li><p>原型对象本身其实就是普通对象（但 <code>Function.prototype</code> 除外，它是函数对象）；</p></li><li><p>原型和原型链是JS实现继承的一种模型。原型链的形成是靠__proto__ 而非prototype；</p></li><li><p>至于原型的原型是什么？只有浏览器环境下可访问__proto__属性，代码中如何实现等问题，这里不再赘述，多点尝试和研究吧。</p></li></ol>`,36),t=[o];function i(c,r,l,d,h,u){return n(),a("div",{"data-pagefind-body":!0},t)}const v=s(p,[["render",i]]);export{b as __pageData,v as default};
