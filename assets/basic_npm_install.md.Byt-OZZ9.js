import{_ as a,o as e,c as s,a8 as i}from"./chunks/framework.Q0X2mdF-.js";const l="/assets/npm-error.EApk1dtX.png",n="/assets/yarn-error.D-j4rR8R.png",y=JSON.parse('{"title":"npm安装依赖报错","description":"","frontmatter":{},"headers":[],"relativePath":"basic/npm/install.md","filePath":"basic/npm/install.md","lastUpdated":null}'),p={name:"basic/npm/install.md"},t=i('<h1 id="npm安装依赖报错" tabindex="-1">npm安装依赖报错 <a class="header-anchor" href="#npm安装依赖报错" aria-label="Permalink to &quot;npm安装依赖报错&quot;">​</a></h1><p><img src="'+l+`" alt="image.png"> 安装依赖时出现这样的依赖冲突报错，<code>package-a</code> 依赖 <code>webpack4</code> 版本，而 <code>package-b</code> 依赖 <code>webpack5</code> 版本，因此npm会阻止安装来避免版本不兼容。 查看 <code>uglifyjs-webpack-plugin</code> 的 <code>package.json</code>文件，其<code>peerDependencies</code>配置如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;peerDependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;webpack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^4.0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span></code></pre></div><blockquote><p>Peer Dependencies 是一种依赖声明，表示包需要与项目的其他依赖共存，并依赖其特定版本。</p></blockquote><h1 id="解决方式" tabindex="-1">解决方式 <a class="header-anchor" href="#解决方式" aria-label="Permalink to &quot;解决方式&quot;">​</a></h1><p>最直观的解决思路就是通过修改版本来修复冲突。</p><h2 id="手动更新依赖" tabindex="-1">手动更新依赖 <a class="header-anchor" href="#手动更新依赖" aria-label="Permalink to &quot;手动更新依赖&quot;">​</a></h2><ol><li>检查冲突的库是否有更新版本（可能支持新的 <code>Peer Dependency</code>）;</li><li>如果冲突库没有更新，可以尝试降级项目中的相关依赖。</li></ol><p>再次尝试，但是需要注意版本更新后是否影响到功能。</p><h2 id="legacy-peer-deps" tabindex="-1">--legacy-peer-deps <a class="header-anchor" href="#legacy-peer-deps" aria-label="Permalink to &quot;--legacy-peer-deps&quot;">​</a></h2><p>这是截图中给出的方式之一，带上它执行时会：</p><ol><li>忽略 <code>Peer Dependency</code> 的版本冲突；</li><li>强制安装可能不兼容的依赖；</li><li>可能会导致的问题有：</li></ol><ul><li>运行时错误：由于版本不兼容，依赖可能无法正常工作；</li><li>隐性问题：安装完成后，冲突可能在测试或生产环境中暴露。</li></ul><p>因此这并不是首选方案，如果无脑使用它，依赖会越来越难以维护。</p><h2 id="force" tabindex="-1">--force <a class="header-anchor" href="#force" aria-label="Permalink to &quot;--force&quot;">​</a></h2><p><code>npm</code> 还给出了另一个方案，即使用<code>--force</code>执行，它会尝试安装冲突依赖的多个版本，而不是只解决一个版本冲突。 比如 <code>package-a</code> 需要 <code>lodash@^4.17.0</code>，<code>package-b</code> 需要 <code>lodash@^3.10.0</code>，使用<code>--force</code>后，<code>lodash@^4.17.0</code> 和 <code>lodash@^3.10.0</code> 会分别安装在 <code>package-a</code> 和 <code>package-b</code> 的 <code>node_modules</code> 下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">node_modules</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  lodash@</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  package-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    node_modules</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      lodash@</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  package-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    node_modules</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      lodash@</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span></code></pre></div><p>这样虽然能够解决冲突，但是同样如果无脑使用，会造成多个版本的依赖可能导致代码体积增大或运行时行为不一致，也不是首选方案。</p><h3 id="与-legacy-peer-deps-的区别" tabindex="-1">与 --legacy-peer-deps 的区别 <a class="header-anchor" href="#与-legacy-peer-deps-的区别" aria-label="Permalink to &quot;与 --legacy-peer-deps 的区别&quot;">​</a></h3><ol><li>--legacy-peer-deps:</li></ol><ul><li>跳过对 <code>peerDependencies</code> 的版本冲突检查，不强制统一版本；</li><li>安装的依赖通常只有一个版本（按依赖关系选择最近的版本）。</li><li>模拟 <code>npm@6</code> 的行为。</li></ul><ol start="2"><li>--force:</li></ol><ul><li>不仅忽略 <code>peerDependencies</code> 冲突，还忽略 所有依赖关系冲突，范围更广；</li><li>会安装多个版本的冲突依赖，强行满足每个依赖的要求。</li></ul><h2 id="使用yarn或pnpm" tabindex="-1">使用yarn或pnpm <a class="header-anchor" href="#使用yarn或pnpm" aria-label="Permalink to &quot;使用yarn或pnpm&quot;">​</a></h2><p>实际上这三个包管理器对于冲突版本处理的方式都是多版本共存，只是pnpm中的多版本依赖，只会在全局存储中保留一份，占用更少的磁盘空间。它们之间更大的区别主要是磁盘空间占用和安装性能。然而在依赖提升方面，npm的处理相较于yarn更加保守，不会强制合并冲突版本。同样的依赖使用yarn再次安装： <img src="`+n+'" alt="image.png"> 只有警告，仍然可以继续安装。</p><h1 id="版本固定" tabindex="-1">版本固定 <a class="header-anchor" href="#版本固定" aria-label="Permalink to &quot;版本固定&quot;">​</a></h1><h2 id="版本" tabindex="-1">版本 <a class="header-anchor" href="#版本" aria-label="Permalink to &quot;版本&quot;">​</a></h2><p>经常可以看到依赖版本标志有~，^，以及什么前缀都没有</p><ol><li>^（Caret）： 允许自动更新到最新的主要版本（major version），但不更新到下一个主要版本。 示例：^1.2.3 表示可以更新到 1.x.x（如 1.3.0、1.4.5 等），但不会更新到 2.0.0。</li><li>~（Tilde）： 允许自动更新到最新的次要版本（minor version），但不更新到下一个次要版本。 示例：~1.2.3 表示可以更新到 1.2.x（如 1.2.4、1.2.5 等），但不会更新到 1.3.0。</li><li>具体版本号</li></ol><ul><li>指定一个确切的版本号，不允许更新。</li><li>示例：1.2.3 表示只能安装 1.2.3 这一版本。</li></ul><p>在需要确保稳定性、避免潜在问题、团队协作一致性等情况下，建议固定依赖的版本号。固定版本号能够减少不确定性，提升项目的可预测性。然而，在开发和测试阶段，可以使用范围版本，以便快速获取最新功能和修复。可以在特定的情况下灵活选择使用固定版本或范围版本的策略，以便在开发和生产环境中保持最佳平衡。</p>',31),o=[t];function d(h,c,r,k,g,E){return e(),s("div",{"data-pagefind-body":!0},o)}const m=a(p,[["render",d]]);export{y as __pageData,m as default};
